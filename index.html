<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Relational Drainage Theory — Formal Framework</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three.quarks@0.15.3/dist/three.quarks.min.js"></script>
<style>
:root {
  --bg: #fafafa;
  --text: #1a1a1a;
  --accent: #2c3e50;
  --border: #ddd;
  --highlight: #f8f4e8;
  --blue: #34495e;
  --tab-bg: #ecf0f1;
  --tab-active: #2c3e50;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, Georgia, serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  padding: 2rem;
  max-width: 900px;
  margin: 0 auto;
}
header {
  text-align: center;
  border-bottom: 3px double var(--accent);
  padding-bottom: 1.5rem;
  margin-bottom: 1.5rem;
}
h1 { font-size: 2.2rem; color: var(--accent); margin-bottom: 0.5rem; letter-spacing: 1px; }
.subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
.authors { margin-top: 1rem; color: #555; font-size: 0.95rem; }
.version { font-size: 0.85rem; color: #888; margin-top: 0.5rem; }

/* Tab Navigation */
.tab-nav {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 2rem;
  border-bottom: 2px solid var(--border);
  padding-bottom: 0;
  flex-wrap: wrap;
}
.tab-btn {
  padding: 0.75rem 1.5rem;
  border: none;
  background: var(--tab-bg);
  color: var(--text);
  font-family: inherit;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 6px 6px 0 0;
  transition: all 0.2s ease;
  border: 1px solid var(--border);
  border-bottom: none;
  margin-bottom: -2px;
}
.tab-btn:hover {
  background: #dfe6e9;
}
.tab-btn.active {
  background: var(--tab-active);
  color: white;
  border-color: var(--tab-active);
}
.tab-content {
  display: none;
  animation: fadeIn 0.3s ease;
}
.tab-content.active {
  display: block;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Section styles */
section { margin-bottom: 2.5rem; }
h2 {
  color: var(--accent);
  border-bottom: 1px solid var(--border);
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
  font-size: 1.4rem;
}
h3 { color: var(--blue); margin: 1.5rem 0 0.75rem; font-size: 1.15rem; }
h4 { color: #555; margin: 1rem 0 0.5rem; font-size: 1rem; font-style: italic; }
p { margin-bottom: 1rem; text-align: justify; }
.axiom, .theorem, .definition, .corollary {
  background: var(--highlight);
  border-left: 4px solid var(--accent);
  padding: 1rem;
  margin: 1rem 0;
}
.axiom::before { content: "Axiom. "; font-weight: bold; color: var(--accent); }
.theorem::before { content: "Theorem. "; font-weight: bold; color: var(--accent); }
.definition::before { content: "Definition. "; font-weight: bold; color: var(--accent); }
.corollary::before { content: "Corollary. "; font-weight: bold; color: var(--accent); }
.boxed {
  border: 2px solid var(--accent);
  padding: 1rem;
  text-align: center;
  margin: 1.5rem 0;
  background: #fff;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 1rem 0;
  font-size: 0.95rem;
}
th, td {
  border: 1px solid var(--border);
  padding: 0.6rem;
  text-align: left;
}
th { background: var(--highlight); font-weight: 600; }
tr:nth-child(even) { background: #fafafa; }
.credit-box {
  background: linear-gradient(135deg, #f5f7fa 0%, #e8ecf1 100%);
  border: 1px solid #ccd;
  border-radius: 6px;
  padding: 1.25rem;
  margin: 1rem 0;
}
.credit-box h4 { margin-top: 0; color: var(--accent); }
.test-box {
  background: #fff;
  border: 2px solid #27ae60;
  border-radius: 6px;
  padding: 1.25rem;
  margin: 1rem 0;
}
.test-box h4 { color: #27ae60; margin-top: 0; }
.app-box {
  background: #fff;
  border: 2px solid #3498db;
  border-radius: 6px;
  padding: 1.25rem;
  margin: 1rem 0;
}
.app-box h4 { color: #3498db; margin-top: 0; }
.dependency-tree {
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  background: #2c3e50;
  color: #ecf0f1;
  padding: 1rem;
  border-radius: 4px;
  overflow-x: auto;
  white-space: pre;
}
footer {
  text-align: center;
  border-top: 3px double var(--accent);
  padding-top: 1.5rem;
  margin-top: 3rem;
  color: #666;
  font-size: 0.9rem;
}
.epigraph {
  font-style: italic;
  text-align: center;
  color: #555;
  margin: 2rem 0;
  padding: 1rem;
}
.confidence {
  display: inline-block;
  background: var(--accent);
  color: white;
  padding: 0.2rem 0.5rem;
  border-radius: 3px;
  font-size: 0.8rem;
}
@media (max-width: 600px) {
  body { padding: 1rem; }
  h1 { font-size: 1.6rem; }
  .tab-nav { gap: 0.25rem; }
  .tab-btn { padding: 0.5rem 0.75rem; font-size: 0.85rem; }
}

/* Visual Journey Tab Styles - Encapsulated Panels with Point Clouds */
.journey-intro {
  text-align: center;
  font-size: 1.2rem;
  color: #666;
  margin-bottom: 2rem;
  font-style: italic;
  max-width: 700px;
  margin-left: auto;
  margin-right: auto;
}

/* Foundation Panels - Large Encapsulated Views */
.foundation-panels {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  margin: 2rem 0;
}
.foundation-panel {
  display: grid;
  grid-template-columns: 1fr 1fr;
  background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
  border-radius: 16px;
  overflow: hidden;
  min-height: 400px;
  border: 1px solid rgba(255,255,255,0.1);
  transition: all 0.4s ease;
}
.foundation-panel:hover {
  border-color: rgba(255,255,255,0.2);
  box-shadow: 0 20px 60px rgba(0,0,0,0.4);
}
.foundation-panel[data-foundation="F1"] { border-left: 4px solid #f5f5dc; }
.foundation-panel[data-foundation="F2"] { border-left: 4px solid #8b5cf6; }
.foundation-panel[data-foundation="F3"] { border-left: 4px solid #06b6d4; }
.foundation-panel[data-foundation="F4"] { border-left: 4px solid #ec4899; }

/* 3D Canvas Container */
.panel-canvas {
  position: relative;
  background: #050510;
  min-height: 400px;
}
.panel-canvas canvas {
  width: 100% !important;
  height: 100% !important;
  display: block;
}
.canvas-label {
  position: absolute;
  bottom: 1rem;
  left: 1rem;
  font-family: 'SF Mono', monospace;
  font-size: 0.75rem;
  color: rgba(255,255,255,0.4);
  pointer-events: none;
}

/* Panel Content - Analogy & Description */
.panel-content {
  padding: 2.5rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.panel-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1.5rem;
}
.panel-id {
  font-size: 2rem;
  font-weight: 700;
  opacity: 0.2;
  font-family: 'SF Mono', monospace;
}
.foundation-panel[data-foundation="F1"] .panel-id { color: #f5f5dc; }
.foundation-panel[data-foundation="F2"] .panel-id { color: #8b5cf6; }
.foundation-panel[data-foundation="F3"] .panel-id { color: #06b6d4; }
.foundation-panel[data-foundation="F4"] .panel-id { color: #ec4899; }

.panel-titles h3 {
  color: #e8e8e8;
  font-size: 1.5rem;
  margin: 0 0 0.25rem;
  font-style: normal;
}
.panel-titles .analogy-name {
  font-size: 1rem;
  font-style: italic;
  opacity: 0.7;
}
.foundation-panel[data-foundation="F1"] .analogy-name { color: #f5f5dc; }
.foundation-panel[data-foundation="F2"] .analogy-name { color: #8b5cf6; }
.foundation-panel[data-foundation="F3"] .analogy-name { color: #06b6d4; }
.foundation-panel[data-foundation="F4"] .analogy-name { color: #ec4899; }

.panel-formal {
  font-family: 'SF Mono', monospace;
  font-size: 1.1rem;
  padding: 1rem;
  background: rgba(0,0,0,0.4);
  border-radius: 8px;
  margin-bottom: 1.5rem;
  border-left: 3px solid;
}
.foundation-panel[data-foundation="F1"] .panel-formal { color: #f5f5dc; border-color: #f5f5dc; }
.foundation-panel[data-foundation="F2"] .panel-formal { color: #c4b5fd; border-color: #8b5cf6; }
.foundation-panel[data-foundation="F3"] .panel-formal { color: #67e8f9; border-color: #06b6d4; }
.foundation-panel[data-foundation="F4"] .panel-formal { color: #f9a8d4; border-color: #ec4899; }

.panel-desc {
  color: #a0a0a0;
  line-height: 1.7;
  font-size: 0.95rem;
  margin-bottom: 1.5rem;
  text-align: left;
}
.panel-analogy-text {
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  padding: 1rem;
  font-style: italic;
  color: #888;
  border-left: 3px solid rgba(255,255,255,0.2);
}

/* Derived Results Chips */
.panel-results {
  margin-top: auto;
  padding-top: 1rem;
  border-top: 1px solid rgba(255,255,255,0.1);
}
.panel-results h5 {
  color: #666;
  font-size: 0.8rem;
  margin-bottom: 0.5rem;
  font-style: normal;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.result-chip {
  display: inline-block;
  padding: 0.3rem 0.6rem;
  margin: 0.2rem;
  border-radius: 15px;
  font-size: 0.7rem;
  background: rgba(99,102,241,0.15);
  color: #a5b4fc;
  border: 1px solid rgba(99,102,241,0.3);
}
.result-chip.math { background: rgba(139,92,246,0.15); border-color: rgba(139,92,246,0.3); color: #c4b5fd; }
.result-chip.physics { background: rgba(6,182,212,0.15); border-color: rgba(6,182,212,0.3); color: #67e8f9; }
.result-chip.prediction { background: rgba(34,197,94,0.15); border-color: rgba(34,197,94,0.3); color: #86efac; }

/* Panel Content Elements */
.foundation-name {
  color: #888;
  font-size: 0.9rem;
  font-style: italic;
  margin: 0;
}
.foundation-formal {
  font-family: 'SF Mono', monospace;
  font-size: 1.1rem;
  padding: 0.75rem 1rem;
  background: rgba(0,0,0,0.4);
  border-radius: 8px;
  margin: 1rem 0;
  display: inline-block;
}
.foundation-panel[data-foundation="F1"] .foundation-formal { color: #f5f5dc; border-left: 3px solid #f5f5dc; }
.foundation-panel[data-foundation="F2"] .foundation-formal { color: #c4b5fd; border-left: 3px solid #8b5cf6; }
.foundation-panel[data-foundation="F3"] .foundation-formal { color: #67e8f9; border-left: 3px solid #06b6d4; }
.foundation-panel[data-foundation="F4"] .foundation-formal { color: #f9a8d4; border-left: 3px solid #ec4899; }

.foundation-desc {
  color: #a0a0a0;
  line-height: 1.7;
  font-size: 0.95rem;
  margin: 1rem 0;
  text-align: left;
}
.derived-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 0.3rem;
  margin: 1rem 0;
}
.analogy-text {
  background: rgba(255,255,255,0.03);
  border-radius: 8px;
  padding: 1rem;
  font-size: 0.9rem;
  color: #666;
  border-left: 3px solid rgba(255,255,255,0.1);
  margin-top: auto;
}

/* Responsive */
@media (max-width: 900px) {
  .foundation-panel {
    grid-template-columns: 1fr;
  }
  .panel-canvas {
    min-height: 300px;
  }
}

/* ============================================================
   INNOVATIONS TAB STYLES
   ============================================================ */
.innovations-intro {
  text-align: center;
  max-width: 800px;
  margin: 0 auto 3rem;
}
.innovations-intro h2 {
  color: #e8e8e8;
  font-size: 2rem;
  margin-bottom: 1rem;
}
.innovations-intro p {
  color: #888;
  font-size: 1.1rem;
  line-height: 1.7;
}

.innovation-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}

.innovation-card {
  background: linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%);
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.08);
  transition: all 0.4s ease;
  position: relative;
}
.innovation-card:hover {
  transform: translateY(-4px);
  border-color: rgba(255,255,255,0.15);
  box-shadow: 0 20px 60px rgba(0,0,0,0.4);
}

.innovation-canvas {
  height: 200px;
  background: #050510;
  position: relative;
  overflow: hidden;
}
.innovation-canvas canvas {
  width: 100% !important;
  height: 100% !important;
}

.innovation-content {
  padding: 1.5rem;
}
.innovation-header {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
}
.innovation-icon {
  width: 48px;
  height: 48px;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  flex-shrink: 0;
}
.innovation-card[data-type="quantum"] .innovation-icon { background: rgba(139,92,246,0.2); }
.innovation-card[data-type="gravity"] .innovation-icon { background: rgba(245,245,220,0.15); }
.innovation-card[data-type="computing"] .innovation-icon { background: rgba(6,182,212,0.2); }
.innovation-card[data-type="energy"] .innovation-icon { background: rgba(236,72,153,0.2); }
.innovation-card[data-type="info"] .innovation-icon { background: rgba(34,197,94,0.2); }
.innovation-card[data-type="cognitive"] .innovation-icon { background: rgba(249,115,22,0.2); }

.innovation-title {
  font-size: 1.25rem;
  color: #e8e8e8;
  margin: 0 0 0.25rem;
}
.innovation-subtitle {
  font-size: 0.85rem;
  color: #666;
  margin: 0;
}

.innovation-desc {
  color: #a0a0a0;
  font-size: 0.95rem;
  line-height: 1.6;
  margin-bottom: 1rem;
}

.innovation-insight {
  background: rgba(255,255,255,0.03);
  border-left: 3px solid;
  padding: 0.75rem 1rem;
  margin-bottom: 1rem;
  border-radius: 0 8px 8px 0;
}
.innovation-card[data-type="quantum"] .innovation-insight { border-color: #8b5cf6; }
.innovation-card[data-type="gravity"] .innovation-insight { border-color: #f5f5dc; }
.innovation-card[data-type="computing"] .innovation-insight { border-color: #06b6d4; }
.innovation-card[data-type="energy"] .innovation-insight { border-color: #ec4899; }
.innovation-card[data-type="info"] .innovation-insight { border-color: #22c55e; }
.innovation-card[data-type="cognitive"] .innovation-insight { border-color: #f97316; }

.innovation-insight strong {
  color: #ccc;
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.innovation-insight p {
  color: #888;
  font-size: 0.9rem;
  margin: 0.5rem 0 0;
  font-style: italic;
}

.innovation-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-top: 1rem;
  border-top: 1px solid rgba(255,255,255,0.05);
}
.innovation-timeline {
  font-size: 0.8rem;
  color: #666;
}
.innovation-foundation {
  font-size: 0.75rem;
  padding: 0.25rem 0.75rem;
  border-radius: 20px;
  background: rgba(255,255,255,0.05);
  color: #888;
}

@media (max-width: 768px) {
  .innovation-grid {
    grid-template-columns: 1fr;
  }
}

/* Design Spec Expandable Sections */
.design-spec-toggle {
  width: 100%;
  padding: 0.75rem 1rem;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 8px;
  color: #888;
  font-size: 0.85rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 1rem;
  transition: all 0.3s ease;
}
.design-spec-toggle:hover {
  background: rgba(255,255,255,0.06);
  color: #aaa;
}
.design-spec-toggle .toggle-icon {
  transition: transform 0.3s ease;
}
.design-spec-toggle.active .toggle-icon {
  transform: rotate(180deg);
}

.design-spec {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease, padding 0.4s ease;
  background: rgba(0,0,0,0.3);
  border-radius: 0 0 12px 12px;
  margin: 0 -1.5rem -1.5rem;
}
.design-spec.active {
  max-height: 2000px;
  padding: 1.5rem;
}

.spec-section {
  margin-bottom: 1.5rem;
}
.spec-section:last-child {
  margin-bottom: 0;
}
.spec-section h4 {
  color: #e8e8e8;
  font-size: 0.9rem;
  margin: 0 0 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.spec-section h4 .spec-icon {
  opacity: 0.6;
}

.spec-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}
.spec-table tr {
  border-bottom: 1px solid rgba(255,255,255,0.05);
}
.spec-table tr:last-child {
  border-bottom: none;
}
.spec-table td {
  padding: 0.5rem 0;
  vertical-align: top;
}
.spec-table td:first-child {
  color: #888;
  width: 40%;
  padding-right: 1rem;
}
.spec-table td:last-child {
  color: #a0a0a0;
}

.spec-list {
  margin: 0;
  padding-left: 1.25rem;
  color: #a0a0a0;
  font-size: 0.85rem;
  line-height: 1.7;
}
.spec-list li {
  margin-bottom: 0.25rem;
}

.spec-diagram {
  background: rgba(0,0,0,0.4);
  border-radius: 8px;
  padding: 1rem;
  font-family: 'SF Mono', 'Consolas', monospace;
  font-size: 0.75rem;
  color: #888;
  overflow-x: auto;
  white-space: pre;
  line-height: 1.4;
}

.spec-warning {
  background: rgba(234,179,8,0.1);
  border-left: 3px solid #eab308;
  padding: 0.75rem 1rem;
  border-radius: 0 8px 8px 0;
  font-size: 0.85rem;
  color: #a0a0a0;
}
.spec-warning strong {
  color: #eab308;
}

.full-spec-link {
  display: inline-block;
  margin-top: 1rem;
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, rgba(139,92,246,0.2), rgba(6,182,212,0.2));
  border: 1px solid rgba(139,92,246,0.4);
  border-radius: 6px;
  color: #a78bfa;
  font-size: 0.85rem;
  text-decoration: none;
  transition: all 0.2s;
}
.full-spec-link:hover {
  background: linear-gradient(135deg, rgba(139,92,246,0.3), rgba(6,182,212,0.3));
  border-color: rgba(139,92,246,0.6);
  color: #c4b5fd;
  text-decoration: none;
}

/* ============================================================
   LANDING PAGE STYLES
   ============================================================ */
.landing-page {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  padding: 2rem;
  background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #0a0a0f 100%);
  position: relative;
  overflow: hidden;
}
.landing-page::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background:
    radial-gradient(ellipse at 20% 30%, rgba(139,92,246,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 80% 70%, rgba(6,182,212,0.08) 0%, transparent 50%),
    radial-gradient(ellipse at 50% 50%, rgba(236,72,153,0.05) 0%, transparent 60%);
  pointer-events: none;
}
.landing-content {
  position: relative;
  z-index: 1;
  max-width: 900px;
}
.landing-classification {
  font-size: 0.85rem;
  color: #8b5cf6;
  text-transform: uppercase;
  letter-spacing: 3px;
  margin-bottom: 1rem;
  font-weight: 600;
}
.landing-title {
  font-size: 3.5rem;
  color: #f5f5dc;
  margin-bottom: 0.5rem;
  letter-spacing: 2px;
  font-weight: 400;
}
.landing-subtitle {
  font-size: 1.4rem;
  color: #888;
  margin-bottom: 2rem;
  font-style: italic;
}
.landing-elevator {
  font-size: 1.15rem;
  color: #b0b0b0;
  line-height: 1.8;
  max-width: 750px;
  margin: 0 auto 2.5rem;
  text-align: justify;
}
.landing-elevator strong {
  color: #06b6d4;
}

.landscape-section {
  margin: 2rem 0;
  padding: 1.5rem;
  background: rgba(0,0,0,0.3);
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.08);
}
.landscape-section h3 {
  color: #ec4899;
  font-size: 1.1rem;
  margin-bottom: 1rem;
  font-weight: 500;
}
.landscape-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  text-align: left;
}
.landscape-item {
  padding: 0.75rem;
  background: rgba(255,255,255,0.02);
  border-radius: 8px;
  border-left: 3px solid rgba(139,92,246,0.5);
}
.landscape-item h4 {
  color: #a5b4fc;
  font-size: 0.95rem;
  margin-bottom: 0.3rem;
  font-weight: 500;
}
.landscape-item p {
  color: #666;
  font-size: 0.8rem;
  margin: 0;
  text-align: left;
}
.landscape-item.rdt-item {
  background: rgba(6,182,212,0.1);
  border-left-color: #06b6d4;
}
.landscape-item.rdt-item h4 {
  color: #67e8f9;
}

.distinctive-box {
  margin: 2rem 0;
  padding: 1.5rem;
  background: linear-gradient(135deg, rgba(245,245,220,0.05), rgba(139,92,246,0.05));
  border: 1px solid rgba(245,245,220,0.2);
  border-radius: 12px;
}
.distinctive-box h3 {
  color: #f5f5dc;
  font-size: 1.1rem;
  margin-bottom: 1rem;
}
.distinctive-list {
  list-style: none;
  text-align: left;
  color: #a0a0a0;
  font-size: 0.95rem;
}
.distinctive-list li {
  padding: 0.5rem 0;
  padding-left: 1.5rem;
  position: relative;
}
.distinctive-list li::before {
  content: '→';
  position: absolute;
  left: 0;
  color: #8b5cf6;
}

.enter-btn {
  display: inline-block;
  padding: 1rem 3rem;
  background: linear-gradient(135deg, #8b5cf6 0%, #06b6d4 100%);
  color: white;
  font-family: inherit;
  font-size: 1.1rem;
  border: none;
  border-radius: 30px;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 2rem;
  letter-spacing: 1px;
}
.enter-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 40px rgba(139,92,246,0.3);
}

.main-site {
  display: none;
}
.main-site.visible {
  display: block;
}
.landing-page.hidden {
  display: none;
}

.landing-authors {
  margin-top: 2rem;
  color: #555;
  font-size: 0.9rem;
}
.landing-version {
  color: #444;
  font-size: 0.8rem;
  margin-top: 0.5rem;
}

/* FAQ Section */
.faq-section {
  margin: 2.5rem 0;
  text-align: left;
}
.faq-section h3 {
  color: #06b6d4;
  font-size: 1.2rem;
  margin-bottom: 1.5rem;
  text-align: center;
}
.faq-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1rem;
}
.faq-item {
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  padding: 1.25rem;
  border: 1px solid rgba(255,255,255,0.06);
  transition: all 0.3s ease;
}
.faq-item:hover {
  border-color: rgba(139,92,246,0.3);
  background: rgba(139,92,246,0.05);
}
.faq-audience {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: #8b5cf6;
  margin-bottom: 0.5rem;
  font-weight: 600;
}
.faq-question {
  color: #e8e8e8;
  font-size: 0.95rem;
  font-style: italic;
  margin-bottom: 0.75rem;
  line-height: 1.5;
}
.faq-answer {
  color: #888;
  font-size: 0.85rem;
  line-height: 1.6;
  margin: 0;
}
.faq-answer strong {
  color: #67e8f9;
}

/* ===============================================
   COMPREHENSIVE ANIMATIONS
   =============================================== */

/* Hero particle canvas */
#hero-particles {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  pointer-events: none;
}

/* Floating animation for elements */
@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

@keyframes floatSlow {
  0%, 100% { transform: translateY(0px) rotate(0deg); }
  50% { transform: translateY(-15px) rotate(2deg); }
}

@keyframes pulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.8; transform: scale(1.02); }
}

@keyframes glow {
  0%, 100% { box-shadow: 0 0 5px rgba(139, 92, 246, 0.3); }
  50% { box-shadow: 0 0 20px rgba(139, 92, 246, 0.6), 0 0 40px rgba(6, 182, 212, 0.3); }
}

@keyframes shimmer {
  0% { background-position: -200% center; }
  100% { background-position: 200% center; }
}

@keyframes slideInUp {
  from { opacity: 0; transform: translateY(30px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes slideInLeft {
  from { opacity: 0; transform: translateX(-30px); }
  to { opacity: 1; transform: translateX(0); }
}

@keyframes ripple {
  0% { transform: scale(0.8); opacity: 1; }
  100% { transform: scale(2.5); opacity: 0; }
}

@keyframes borderFlow {
  0% { border-color: rgba(139, 92, 246, 0.5); }
  33% { border-color: rgba(6, 182, 212, 0.5); }
  66% { border-color: rgba(236, 72, 153, 0.5); }
  100% { border-color: rgba(139, 92, 246, 0.5); }
}

@keyframes textGlow {
  0%, 100% { text-shadow: 0 0 10px rgba(245, 245, 220, 0.3); }
  50% { text-shadow: 0 0 20px rgba(245, 245, 220, 0.6), 0 0 30px rgba(139, 92, 246, 0.4); }
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Landing page animations */
.landing-title {
  animation: textGlow 4s ease-in-out infinite, slideInUp 1s ease-out;
}

.landing-subtitle {
  animation: slideInUp 1s ease-out 0.2s both;
}

.landing-classification {
  animation: slideInUp 1s ease-out 0.1s both;
  background: linear-gradient(90deg, #8b5cf6, #06b6d4, #ec4899, #8b5cf6);
  background-size: 300% 100%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: slideInUp 1s ease-out 0.1s both, gradientShift 6s ease infinite;
}

.landing-elevator {
  animation: slideInUp 1s ease-out 0.3s both;
}

.landscape-item {
  animation: slideInUp 0.6s ease-out both;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
.landscape-item:nth-child(1) { animation-delay: 0.4s; }
.landscape-item:nth-child(2) { animation-delay: 0.5s; }
.landscape-item:nth-child(3) { animation-delay: 0.6s; }
.landscape-item:nth-child(4) { animation-delay: 0.7s; }
.landscape-item:nth-child(5) { animation-delay: 0.8s; }

.landscape-item:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 10px 30px rgba(139, 92, 246, 0.2);
}

.landscape-item.rdt-item {
  animation: glow 3s ease-in-out infinite, slideInUp 0.6s ease-out 0.8s both;
}

.distinctive-box {
  animation: slideInUp 1s ease-out 0.5s both;
}

/* Tab button animations */
.tab-btn {
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  position: relative;
  overflow: hidden;
}

.tab-btn::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  width: 0;
  height: 2px;
  background: linear-gradient(90deg, #8b5cf6, #06b6d4);
  transition: all 0.3s ease;
  transform: translateX(-50%);
}

.tab-btn:hover::after {
  width: 80%;
}

.tab-btn:hover {
  transform: translateY(-2px);
}

.tab-btn.active {
  animation: pulse 2s ease-in-out infinite;
}

/* Card and box animations */
.axiom, .theorem, .definition, .corollary {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  position: relative;
}

.axiom:hover, .theorem:hover, .definition:hover, .corollary:hover {
  transform: translateX(5px);
  box-shadow: -3px 0 15px rgba(139, 92, 246, 0.2);
}

.boxed {
  transition: all 0.4s ease;
  position: relative;
  overflow: hidden;
}

.boxed::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
  transition: left 0.5s ease;
}

.boxed:hover::before {
  left: 100%;
}

.boxed:hover {
  transform: scale(1.01);
  box-shadow: 0 5px 20px rgba(0,0,0,0.1);
}

/* Credit box animations */
.credit-box {
  transition: all 0.4s ease;
  position: relative;
}

.credit-box:hover {
  transform: translateX(8px);
  border-left-width: 6px;
}

/* Table row animations */
table tr {
  transition: all 0.3s ease;
}

table tr:hover {
  background: rgba(139, 92, 246, 0.05) !important;
  transform: scale(1.005);
}

/* FAQ item animations */
.faq-item {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.faq-item:hover {
  transform: translateY(-5px) scale(1.02);
  box-shadow: 0 15px 35px rgba(139, 92, 246, 0.15);
}

/* Foundation panel animations (Visual Journey) */
.foundation-panel {
  transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.foundation-panel:hover {
  transform: translateY(-10px);
  box-shadow: 0 20px 50px rgba(0,0,0,0.3);
}

.panel-canvas {
  transition: all 0.5s ease;
}

.foundation-panel:hover .panel-canvas {
  transform: scale(1.05);
}

/* Spec card animations (if any) */
.spec-card, .innovation-card {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.spec-card:hover, .innovation-card:hover {
  transform: translateY(-8px) scale(1.02);
  box-shadow: 0 15px 40px rgba(139, 92, 246, 0.2);
}

/* Result chip animations */
.result-chip {
  transition: all 0.3s ease;
  cursor: default;
}

.result-chip:hover {
  transform: scale(1.1);
  box-shadow: 0 3px 10px rgba(0,0,0,0.2);
}

/* Enter button animation */
.enter-btn {
  animation: pulse 2s ease-in-out infinite, glow 3s ease-in-out infinite;
  transition: all 0.3s ease;
}

.enter-btn:hover {
  transform: scale(1.05);
  animation: none;
  box-shadow: 0 0 30px rgba(139, 92, 246, 0.6), 0 0 60px rgba(6, 182, 212, 0.3);
}

/* Scroll indicator animation */
.scroll-indicator {
  animation: float 2s ease-in-out infinite;
}

/* Section heading animations */
h2 {
  position: relative;
  overflow: hidden;
}

h2::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 0;
  height: 2px;
  background: linear-gradient(90deg, #8b5cf6, #06b6d4, #ec4899);
  transition: width 0.5s ease;
}

section:hover h2::after {
  width: 100%;
}

/* Dependency tree animation */
.dependency-tree {
  transition: all 0.4s ease;
}

.dependency-tree:hover {
  transform: scale(1.02);
  box-shadow: 0 5px 20px rgba(0,0,0,0.1);
}

/* Epigraph animation */
.epigraph {
  transition: all 0.4s ease;
  position: relative;
}

.epigraph:hover {
  transform: scale(1.02);
  box-shadow: 0 5px 30px rgba(139, 92, 246, 0.1);
}

/* Link animations */
a {
  transition: all 0.2s ease;
  position: relative;
}

a:hover {
  color: #06b6d4;
}

/* Loading animation for canvases */
.panel-canvas::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 30px;
  height: 30px;
  border: 2px solid rgba(139, 92, 246, 0.3);
  border-top-color: #8b5cf6;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  transform: translate(-50%, -50%);
  z-index: 1;
}

.panel-canvas canvas ~ .panel-canvas::before {
  display: none;
}

@keyframes spin {
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* Staggered animation helper */
.stagger-1 { animation-delay: 0.1s !important; }
.stagger-2 { animation-delay: 0.2s !important; }
.stagger-3 { animation-delay: 0.3s !important; }
.stagger-4 { animation-delay: 0.4s !important; }
.stagger-5 { animation-delay: 0.5s !important; }

/* Smooth scroll behavior */
html {
  scroll-behavior: smooth;
}

/* Intersection observer animation triggers */
.animate-on-scroll {
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.6s ease-out;
}

.animate-on-scroll.visible {
  opacity: 1;
  transform: translateY(0);
}

/* ===============================================
   EQUATION & PHYSICS CONCEPT ANIMATIONS
   =============================================== */

/* Pulsing equations - key formulas get attention */
.eq-highlight {
  display: inline-block;
  padding: 0.5rem 1rem;
  background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(6,182,212,0.1));
  border-radius: 8px;
  animation: eqPulse 3s ease-in-out infinite;
  border: 1px solid transparent;
}

@keyframes eqPulse {
  0%, 100% {
    border-color: rgba(139,92,246,0.2);
    box-shadow: 0 0 10px rgba(139,92,246,0.1);
  }
  50% {
    border-color: rgba(6,182,212,0.4);
    box-shadow: 0 0 25px rgba(6,182,212,0.2), 0 0 40px rgba(139,92,246,0.1);
  }
}

/* Animated equation underline */
.eq-animated::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, #8b5cf6, #06b6d4, #ec4899, #8b5cf6);
  background-size: 200% 100%;
  animation: eqUnderline 3s linear infinite;
}

@keyframes eqUnderline {
  0% { background-position: 0% 50%; }
  100% { background-position: 200% 50%; }
}

/* Physics Visualization Containers */
.physics-viz {
  position: relative;
  width: 100%;
  height: 200px;
  margin: 1.5rem 0;
  background: linear-gradient(135deg, #0a0a14 0%, #1a1a2e 100%);
  border-radius: 12px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.1);
}

.physics-viz svg {
  width: 100%;
  height: 100%;
}

.physics-viz-label {
  position: absolute;
  bottom: 0.5rem;
  left: 0.5rem;
  font-size: 0.7rem;
  color: rgba(255,255,255,0.4);
  font-family: 'SF Mono', monospace;
}

/* Dual Manifold Animation */
.manifold-viz {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
}

.manifold-m-plus, .manifold-m-minus {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'SF Mono', monospace;
  font-weight: 700;
  font-size: 1.5rem;
}

.manifold-m-plus {
  background: radial-gradient(circle, rgba(6,182,212,0.3) 0%, rgba(6,182,212,0.05) 70%, transparent 100%);
  color: #67e8f9;
  animation: manifoldPulse 4s ease-in-out infinite;
  margin-right: -30px;
  z-index: 2;
}

.manifold-m-minus {
  background: radial-gradient(circle, rgba(236,72,153,0.3) 0%, rgba(236,72,153,0.05) 70%, transparent 100%);
  color: #f9a8d4;
  animation: manifoldPulse 4s ease-in-out infinite 2s;
  margin-left: -30px;
  z-index: 1;
}

.manifold-boundary {
  position: absolute;
  width: 4px;
  height: 100px;
  background: linear-gradient(180deg, transparent, #f5f5dc, transparent);
  left: 50%;
  transform: translateX(-50%);
  animation: boundaryGlow 2s ease-in-out infinite;
  z-index: 3;
}

@keyframes manifoldPulse {
  0%, 100% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.05); opacity: 1; }
}

@keyframes boundaryGlow {
  0%, 100% { box-shadow: 0 0 10px rgba(245,245,220,0.3); }
  50% { box-shadow: 0 0 30px rgba(245,245,220,0.8); }
}

/* Drainage Flow Animation */
.drainage-flow {
  position: relative;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.flow-particle {
  position: absolute;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #06b6d4;
  box-shadow: 0 0 10px #06b6d4;
  animation: flowMove 2s linear infinite;
}

.flow-particle:nth-child(1) { animation-delay: 0s; left: 10%; }
.flow-particle:nth-child(2) { animation-delay: 0.4s; left: 20%; }
.flow-particle:nth-child(3) { animation-delay: 0.8s; left: 30%; }
.flow-particle:nth-child(4) { animation-delay: 1.2s; left: 40%; }
.flow-particle:nth-child(5) { animation-delay: 1.6s; left: 50%; }

@keyframes flowMove {
  0% { transform: translateX(0) scale(1); opacity: 0; }
  10% { opacity: 1; }
  90% { opacity: 1; }
  100% { transform: translateX(300px) scale(0.5); opacity: 0; }
}

/* Wave Equation Animation */
.wave-viz {
  position: relative;
  height: 100px;
  overflow: hidden;
}

.wave-line {
  position: absolute;
  width: 200%;
  height: 100%;
  left: 0;
  animation: wavePropagate 3s linear infinite;
}

.wave-line path {
  fill: none;
  stroke: url(#waveGradient);
  stroke-width: 3;
  stroke-linecap: round;
}

@keyframes wavePropagate {
  0% { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

/* Entropy Conservation - See-saw Animation */
.entropy-seesaw {
  position: relative;
  height: 120px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.seesaw-bar {
  width: 200px;
  height: 6px;
  background: linear-gradient(90deg, #06b6d4, #f5f5dc, #ec4899);
  border-radius: 3px;
  transform-origin: center;
  animation: seesawRock 4s ease-in-out infinite;
}

.seesaw-labels {
  display: flex;
  justify-content: space-between;
  width: 240px;
  margin-top: 1rem;
  font-family: 'SF Mono', monospace;
  font-size: 0.85rem;
}

.seesaw-labels span:first-child { color: #67e8f9; }
.seesaw-labels span:last-child { color: #f9a8d4; }

@keyframes seesawRock {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}

/* Superposition Uncertainty Animation */
.superposition-viz {
  position: relative;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.superposition-states {
  position: relative;
  width: 150px;
  height: 80px;
}

.state-blob {
  position: absolute;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  filter: blur(8px);
  animation: stateFlicker 2s ease-in-out infinite;
}

.state-blob:nth-child(1) {
  background: rgba(139,92,246,0.6);
  left: 0;
  top: 10px;
  animation-delay: 0s;
}

.state-blob:nth-child(2) {
  background: rgba(6,182,212,0.6);
  right: 0;
  top: 10px;
  animation-delay: 1s;
}

.state-blob:nth-child(3) {
  background: rgba(236,72,153,0.6);
  left: 45px;
  bottom: 0;
  animation-delay: 0.5s;
}

@keyframes stateFlicker {
  0%, 100% { opacity: 0.4; transform: scale(1); }
  50% { opacity: 0.9; transform: scale(1.2); }
}

/* Path Integral Visualization */
.path-integral-viz {
  position: relative;
  height: 120px;
}

.path-line {
  position: absolute;
  width: 100%;
  height: 100%;
}

.path-line path {
  fill: none;
  stroke-width: 2;
  stroke-linecap: round;
  animation: pathDraw 3s ease-in-out infinite;
}

.path-line:nth-child(1) path { stroke: rgba(139,92,246,0.8); animation-delay: 0s; }
.path-line:nth-child(2) path { stroke: rgba(6,182,212,0.6); animation-delay: 0.3s; }
.path-line:nth-child(3) path { stroke: rgba(236,72,153,0.4); animation-delay: 0.6s; }
.path-line:nth-child(4) path { stroke: rgba(245,245,220,0.3); animation-delay: 0.9s; }

@keyframes pathDraw {
  0% { stroke-dashoffset: 300; opacity: 0; }
  50% { opacity: 1; }
  100% { stroke-dashoffset: 0; opacity: 0; }
}

/* Born Rule Probability Wave */
.born-rule-viz {
  position: relative;
  height: 100px;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  gap: 4px;
  padding: 0 2rem;
}

.prob-bar {
  width: 12px;
  background: linear-gradient(180deg, #8b5cf6, #06b6d4);
  border-radius: 6px 6px 0 0;
  animation: probGrow 2s ease-in-out infinite;
}

.prob-bar:nth-child(1) { height: 20px; animation-delay: 0s; }
.prob-bar:nth-child(2) { height: 35px; animation-delay: 0.1s; }
.prob-bar:nth-child(3) { height: 55px; animation-delay: 0.2s; }
.prob-bar:nth-child(4) { height: 80px; animation-delay: 0.3s; }
.prob-bar:nth-child(5) { height: 70px; animation-delay: 0.4s; }
.prob-bar:nth-child(6) { height: 45px; animation-delay: 0.5s; }
.prob-bar:nth-child(7) { height: 25px; animation-delay: 0.6s; }
.prob-bar:nth-child(8) { height: 15px; animation-delay: 0.7s; }

@keyframes probGrow {
  0%, 100% { transform: scaleY(1); }
  50% { transform: scaleY(1.2); }
}

/* Entanglement Connection Animation */
.entanglement-viz {
  position: relative;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.entangle-particle {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  position: relative;
}

.entangle-particle:first-child {
  background: radial-gradient(circle, #8b5cf6 30%, transparent 70%);
  animation: entangleSpin 2s linear infinite;
}

.entangle-particle:last-child {
  background: radial-gradient(circle, #ec4899 30%, transparent 70%);
  animation: entangleSpin 2s linear infinite reverse;
}

.entangle-connection {
  width: 100px;
  height: 4px;
  background: linear-gradient(90deg, #8b5cf6, #f5f5dc, #ec4899);
  margin: 0 -5px;
  animation: connectionPulse 1s ease-in-out infinite;
}

@keyframes entangleSpin {
  0% { transform: rotate(0deg); box-shadow: 0 0 15px currentColor; }
  100% { transform: rotate(360deg); box-shadow: 0 0 25px currentColor; }
}

@keyframes connectionPulse {
  0%, 100% { opacity: 0.5; transform: scaleX(1); }
  50% { opacity: 1; transform: scaleX(1.1); }
}

/* Speed of Light Wave Animation */
.light-speed-viz {
  position: relative;
  height: 80px;
  overflow: hidden;
}

.photon {
  position: absolute;
  width: 20px;
  height: 4px;
  background: linear-gradient(90deg, transparent, #f5f5dc, transparent);
  border-radius: 2px;
  top: 50%;
  transform: translateY(-50%);
  animation: photonMove 1.5s linear infinite;
}

.photon:nth-child(1) { animation-delay: 0s; }
.photon:nth-child(2) { animation-delay: 0.3s; }
.photon:nth-child(3) { animation-delay: 0.6s; }
.photon:nth-child(4) { animation-delay: 0.9s; }
.photon:nth-child(5) { animation-delay: 1.2s; }

@keyframes photonMove {
  0% { left: -20px; opacity: 0; }
  10% { opacity: 1; }
  90% { opacity: 1; }
  100% { left: 100%; opacity: 0; }
}

/* Lorentz Transformation Grid */
.lorentz-viz {
  position: relative;
  height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.lorentz-grid {
  width: 120px;
  height: 120px;
  border: 2px solid rgba(139,92,246,0.5);
  position: relative;
  animation: lorentzTransform 4s ease-in-out infinite;
}

.lorentz-grid::before,
.lorentz-grid::after {
  content: '';
  position: absolute;
  background: rgba(6,182,212,0.5);
}

.lorentz-grid::before {
  width: 100%;
  height: 2px;
  top: 50%;
  transform: translateY(-50%);
}

.lorentz-grid::after {
  width: 2px;
  height: 100%;
  left: 50%;
  transform: translateX(-50%);
}

@keyframes lorentzTransform {
  0%, 100% { transform: skewX(0deg) scaleX(1); }
  25% { transform: skewX(-15deg) scaleX(1.1); }
  50% { transform: skewX(0deg) scaleX(1); }
  75% { transform: skewX(15deg) scaleX(0.9); }
}

/* Mass-Energy Equivalence Animation */
.mass-energy-viz {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
  height: 80px;
}

.mass-sphere {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: radial-gradient(circle, #8b5cf6, #4c1d95);
  animation: massConvert 4s ease-in-out infinite;
}

.energy-burst {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(245,245,220,0.8) 0%, rgba(245,245,220,0) 70%);
  animation: energyBurst 4s ease-in-out infinite 2s;
  opacity: 0;
}

.mass-equals {
  font-size: 2rem;
  color: #06b6d4;
  font-weight: 700;
}

@keyframes massConvert {
  0%, 45% { transform: scale(1); opacity: 1; }
  50% { transform: scale(0); opacity: 0; }
  55%, 100% { transform: scale(1); opacity: 1; }
}

@keyframes energyBurst {
  0%, 45% { transform: scale(0); opacity: 0; }
  50% { transform: scale(1.5); opacity: 1; }
  70% { transform: scale(2); opacity: 0; }
  100% { transform: scale(0); opacity: 0; }
}

/* Planck Constant Granularity */
.planck-viz {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 3px;
  height: 60px;
  flex-wrap: wrap;
  max-width: 200px;
  margin: 0 auto;
}

.grain-cell {
  width: 12px;
  height: 12px;
  background: rgba(139,92,246,0.3);
  border: 1px solid rgba(139,92,246,0.5);
  border-radius: 2px;
  animation: grainPulse 2s ease-in-out infinite;
}

.grain-cell:nth-child(3n) { animation-delay: 0.3s; }
.grain-cell:nth-child(3n+1) { animation-delay: 0.6s; }
.grain-cell:nth-child(3n+2) { animation-delay: 0.9s; }

@keyframes grainPulse {
  0%, 100% { background: rgba(139,92,246,0.3); }
  50% { background: rgba(6,182,212,0.6); }
}

/* Arrow of Time Animation */
.time-arrow-viz {
  position: relative;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.time-arrow {
  width: 200px;
  height: 4px;
  background: linear-gradient(90deg, #8b5cf6, #06b6d4, #ec4899);
  position: relative;
}

.time-arrow::after {
  content: '';
  position: absolute;
  right: -10px;
  top: 50%;
  transform: translateY(-50%);
  border-left: 15px solid #ec4899;
  border-top: 10px solid transparent;
  border-bottom: 10px solid transparent;
}

.time-particle {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #f5f5dc;
  border-radius: 50%;
  top: 50%;
  transform: translateY(-50%);
  animation: timeFlow 2s linear infinite;
  box-shadow: 0 0 10px #f5f5dc;
}

@keyframes timeFlow {
  0% { left: 0; }
  100% { left: calc(100% - 10px); }
}

/* Cyclic Universe Animation */
.cyclic-viz {
  position: relative;
  height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cycle-ring {
  width: 100px;
  height: 100px;
  border: 3px solid transparent;
  border-radius: 50%;
  position: relative;
  animation: cycleRotate 6s linear infinite;
}

.cycle-ring::before {
  content: '';
  position: absolute;
  inset: -3px;
  border-radius: 50%;
  border: 3px solid;
  border-color: #8b5cf6 #06b6d4 #ec4899 #f5f5dc;
}

.cycle-marker {
  position: absolute;
  width: 12px;
  height: 12px;
  background: #f5f5dc;
  border-radius: 50%;
  top: -6px;
  left: 50%;
  transform: translateX(-50%);
  box-shadow: 0 0 15px #f5f5dc;
}

@keyframes cycleRotate {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* De Broglie Wave-Particle */
.debroglie-viz {
  position: relative;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.wave-packet {
  position: relative;
  width: 150px;
  height: 60px;
}

.packet-wave {
  position: absolute;
  width: 100%;
  height: 100%;
  animation: packetMove 3s linear infinite;
}

.packet-wave svg {
  width: 100%;
  height: 100%;
}

.packet-envelope {
  position: absolute;
  width: 60px;
  height: 30px;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: radial-gradient(ellipse, rgba(139,92,246,0.6) 0%, transparent 70%);
  border-radius: 50%;
  animation: envelopeMove 3s linear infinite;
}

@keyframes packetMove {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(20px); }
}

@keyframes envelopeMove {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-30%, -50%) scale(1.1); }
}

/* Configuration Space Visualization */
.config-space-viz {
  position: relative;
  height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.config-dots {
  position: relative;
  width: 150px;
  height: 100px;
}

.config-dot {
  position: absolute;
  width: 8px;
  height: 8px;
  background: rgba(139,92,246,0.6);
  border-radius: 50%;
  animation: configPulse 2s ease-in-out infinite;
}

.config-dot.active {
  background: #f5f5dc;
  box-shadow: 0 0 15px #f5f5dc;
  animation: activeDot 0.5s ease-in-out infinite alternate;
}

.config-connection {
  position: absolute;
  height: 1px;
  background: rgba(6,182,212,0.3);
  transform-origin: left center;
}

@keyframes configPulse {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 0.8; }
}

@keyframes activeDot {
  0% { transform: scale(1); }
  100% { transform: scale(1.5); }
}

/* Gravity Drainage Field */
.gravity-field-viz {
  position: relative;
  height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.gravity-center {
  width: 30px;
  height: 30px;
  background: radial-gradient(circle, #f5f5dc, #a08c5a);
  border-radius: 50%;
  box-shadow: 0 0 20px rgba(245,245,220,0.5);
  z-index: 2;
}

.gravity-ring {
  position: absolute;
  border: 1px solid rgba(6,182,212,0.3);
  border-radius: 50%;
  animation: gravityWave 3s ease-out infinite;
}

.gravity-ring:nth-child(1) { width: 50px; height: 50px; animation-delay: 0s; }
.gravity-ring:nth-child(2) { width: 80px; height: 80px; animation-delay: 0.5s; }
.gravity-ring:nth-child(3) { width: 110px; height: 110px; animation-delay: 1s; }
.gravity-ring:nth-child(4) { width: 140px; height: 140px; animation-delay: 1.5s; }

@keyframes gravityWave {
  0% { transform: scale(0.5); opacity: 1; }
  100% { transform: scale(1.5); opacity: 0; }
}

/* Dark Energy Evolution */
.dark-energy-viz {
  position: relative;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 2px;
}

.de-bar {
  width: 8px;
  background: linear-gradient(180deg, #ec4899, #8b5cf6);
  border-radius: 4px;
  animation: deGrow 4s ease-in-out infinite;
}

.de-bar:nth-child(1) { height: 20px; animation-delay: 0s; }
.de-bar:nth-child(2) { height: 25px; animation-delay: 0.2s; }
.de-bar:nth-child(3) { height: 30px; animation-delay: 0.4s; }
.de-bar:nth-child(4) { height: 38px; animation-delay: 0.6s; }
.de-bar:nth-child(5) { height: 48px; animation-delay: 0.8s; }
.de-bar:nth-child(6) { height: 55px; animation-delay: 1s; }
.de-bar:nth-child(7) { height: 60px; animation-delay: 1.2s; }
.de-bar:nth-child(8) { height: 65px; animation-delay: 1.4s; }

@keyframes deGrow {
  0%, 100% { transform: scaleY(1); }
  50% { transform: scaleY(1.3); }
}

/* Grade A Animations - Enhanced Status Indicators */
@keyframes gradeAPulse {
  0%, 100% { box-shadow: 0 0 5px rgba(34, 197, 94, 0.3); }
  50% { box-shadow: 0 0 20px rgba(34, 197, 94, 0.6); }
}

@keyframes derivedGlow {
  0%, 100% { text-shadow: 0 0 5px rgba(34, 197, 94, 0.4); }
  50% { text-shadow: 0 0 15px rgba(34, 197, 94, 0.8); }
}

@keyframes connectedGlow {
  0%, 100% { text-shadow: 0 0 5px rgba(249, 115, 22, 0.4); }
  50% { text-shadow: 0 0 12px rgba(249, 115, 22, 0.7); }
}

/* Derived results in dependency tree */
.dependency-tree strong {
  animation: derivedGlow 2s ease-in-out infinite;
}

/* Status table row highlights */
tr[style*="rgba(34,197,94"] {
  animation: gradeAPulse 3s ease-in-out infinite;
}

/* Definition box distinction (D1) */
.definition {
  position: relative;
  overflow: hidden;
}

.definition::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent 0%, rgba(6, 182, 212, 0.05) 50%, transparent 100%);
  animation: shimmer 3s ease-in-out infinite;
  pointer-events: none;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* Boxed equation emphasis */
.boxed {
  transition: all 0.3s ease;
}

.boxed:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 20px rgba(44, 62, 80, 0.15);
}

/* Animated underline for key terms */
.theorem strong, .axiom strong {
  position: relative;
}

.theorem strong::after, .axiom strong::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, var(--accent), #8b5cf6, var(--accent));
  background-size: 200% 100%;
  animation: gradientFlow 2s ease-in-out infinite;
}

@keyframes gradientFlow {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

/* Tab button active state enhancement */
.tab-btn.active {
  position: relative;
  overflow: hidden;
}

.tab-btn.active::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  animation: tabShine 2s ease-in-out infinite;
}

@keyframes tabShine {
  0% { left: -100%; }
  100% { left: 100%; }
}

/* Glossary Symbol Links */
a.sym-link {
  color: var(--accent);
  text-decoration: none;
  border-bottom: 1px dotted var(--accent);
  transition: all 0.2s ease;
  cursor: help;
}
a.sym-link:hover {
  background: rgba(44, 62, 80, 0.1);
  border-bottom-style: solid;
}

/* Glossary Table Styling */
#glossary table {
  font-size: 0.9rem;
}
#glossary td:first-child {
  text-align: center;
  font-family: 'Times New Roman', serif;
  vertical-align: middle;
  background: rgba(44, 62, 80, 0.05);
}
#glossary tr:target {
  animation: highlightRow 2s ease-out;
}
@keyframes highlightRow {
  0% { background: rgba(139, 92, 246, 0.3); }
  100% { background: transparent; }
}

/* Glossary Section Headers */
#glossary h3 {
  margin-top: 2.5rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border);
}
#glossary h3:first-of-type {
  border-top: none;
  margin-top: 1.5rem;
}
</style>
</head>
<body>

<!-- LANDING PAGE -->
<div class="landing-page" id="landingPage">
  <canvas id="hero-particles"></canvas>
  <div class="landing-content">
    <p class="landing-classification">Thermodynamic Emergent Spacetime with Finite Relational Substrate</p>
    <h1 class="landing-title">Relational Drainage Theory</h1>
    <p class="landing-subtitle">An emergent spacetime framework combining entropic gravity with CPT-symmetric cosmology</p>

    <p class="landing-elevator">
      RDT proposes that spacetime, gravity, and quantum mechanics emerge from a <strong>finite configuration space</strong>
      (the "possibilities block") equipped with a natural metric. The universe explores this space through
      <strong>thermodynamic drainage</strong> — paths of steepest entropy increase — which manifests as the arrow of time,
      gravitational attraction, and quantum uncertainty. A <strong>CPT-symmetric dual manifold</strong> ensures global
      conservation while permitting local irreversibility.
    </p>

    <div class="landscape-section">
      <h3>Position in the Quantum Gravity Landscape</h3>
      <div class="landscape-grid">
        <div class="landscape-item">
          <h4>String Theory</h4>
          <p>Extra dimensions, continuous</p>
        </div>
        <div class="landscape-item">
          <h4>Loop Quantum Gravity</h4>
          <p>Spin networks, background-free</p>
        </div>
        <div class="landscape-item">
          <h4>Causal Sets</h4>
          <p>Discrete events, partial order</p>
        </div>
        <div class="landscape-item">
          <h4>Entropic Gravity</h4>
          <p>Thermodynamic emergence</p>
        </div>
        <div class="landscape-item rdt-item">
          <h4>RDT (This Framework)</h4>
          <p>Finite substrate + entropic emergence + CPT duality</p>
        </div>
      </div>
    </div>

    <div class="distinctive-box">
      <h3>What Makes RDT Distinctive</h3>
      <ul class="distinctive-list">
        <li><strong>Finite totality</strong> — No infinities; |Ω| ≈ 10^(10^122) configurations</li>
        <li><strong>Metric structure</strong> — Distance function d(σ,σ') defines adjacency in possibility space</li>
        <li><strong>Traversal = experience</strong> — Path through Ω is physical reality unfolding</li>
        <li><strong>CPT boundary</strong> — Dual manifold M⁺/M⁻ sharing boundary Σ (after Boyle-Turok)</li>
        <li><strong>Testable predictions</strong> — Specific numerical predictions for κ ≈ 1/4π, force scaling</li>
      </ul>
    </div>

    <div class="faq-section">
      <h3>Frequently Asked Questions by Audience</h3>
      <div class="faq-grid">

        <div class="faq-item">
          <p class="faq-audience">String Theorists</p>
          <p class="faq-question">"Interesting, but where's the UV completion?"</p>
          <p class="faq-answer">RDT sidesteps UV divergences by construction: <strong>Ω is finite</strong>. There's no continuum to regularize. The "Planck scale" emerges as the minimum Ω-distance, not as a cutoff imposed on an underlying continuum. UV completion isn't needed when there's nothing above to complete.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Loop Quantum Gravity</p>
          <p class="faq-question">"Similar spirit, but how does Lorentz invariance emerge?"</p>
          <p class="faq-answer">Like LQG's spin networks, RDT is background-independent. Lorentz symmetry emerges statistically: the <strong>metric d(σ,σ') on Ω</strong> generates emergent geometry that respects local Lorentz invariance at scales >> l_P. Discrete substrate, continuous-looking physics — same resolution as LQG proposes.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Entropic Gravity Fans</p>
          <p class="faq-question">"Finally someone building on Verlinde properly!"</p>
          <p class="faq-answer">Exactly. RDT takes Jacobson (1995) and Verlinde (2010) seriously: <strong>gravity IS entropy gradient</strong>. We add the substrate (Ω with metric), the dual manifold (M⁺/M⁻ for conservation), and derive testable predictions (κ ≈ 1/4π). This is entropic gravity with foundations.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Phenomenologists</p>
          <p class="faq-question">"Give me the κ experiment — I'll test it."</p>
          <p class="faq-answer">See the <strong>Entropic Propulsion</strong> innovation. Prediction: asymmetric entropy generation produces thrust at ~1 μN/kW. Distinguishing test: vary temperature at constant power. Photon pressure unchanged; EPS force scales with T. Torsion balance experiment, ~$1M, falsifiable within 3 years.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Philosophers of Physics</p>
          <p class="faq-question">"Ontic structural realism made physical?"</p>
          <p class="faq-answer">Yes. RDT is explicitly <strong>relational</strong>: configurations σ have no intrinsic properties beyond their relations (adjacency in Ω). Space, time, and matter emerge from structure. This is Ladyman-style OSR with mathematical specificity — the "structure" is (Ω, d, γ, CPT).</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Mainstream Physics</p>
          <p class="faq-question">"Speculative, but at least it's falsifiable."</p>
          <p class="faq-answer">Correct. RDT makes <strong>specific predictions</strong>: κ = 1/4π, entropic thrust scaling, Boyle-Turok CMB signatures, deviations from Born rule at Planck statistics. Any null result at sufficient precision rules out the framework. That's the minimum bar for taking speculation seriously.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">Time & Entropy Questions</p>
          <p class="faq-question">"Can RDT reverse time or entropy locally?"</p>
          <p class="faq-answer"><strong>What RDT claims:</strong> Time ≡ traversal direction (F3); entropy is conserved across M⁺ + M⁻ (F4); M⁻ has reversed time arrow from our perspective. <strong>What RDT does NOT claim:</strong> Local time reversal via entropy manipulation; access to M⁻ through local experiments; entropy decrease without export elsewhere. The boundary Σ is cosmological (Big Bang), not locally accessible. Standard thermodynamics applies within M⁺. Local entropy can decrease (refrigerators, life) but global S⁺ still increases — no loopholes.</p>
        </div>

        <div class="faq-item">
          <p class="faq-audience">CPT Symmetry Questions</p>
          <p class="faq-question">"Is there a 'me' in M⁻ doing things backwards?"</p>
          <p class="faq-answer"><strong>RDT inherits Boyle-Turok cosmology</strong>, which says M⁻ is the CPT conjugate of M⁺ — not that every event is literally mirrored. CPT symmetry means: C (matter↔antimatter), P (left↔right), T (time reversed). The claim is about <strong>physical law symmetry</strong> and <strong>entropy conservation</strong>, not event-by-event correspondence. From within M⁻, their arrow of time feels normal to them. Whether there's a "you" in M⁻ is philosophical extrapolation beyond what RDT specifies.</p>
        </div>

      </div>
    </div>

    <button class="enter-btn" onclick="enterSite()">Enter the Framework</button>

    <p class="landing-authors">By Andrew Craton</p>
    <p class="landing-version">January 2026 — Built upon Jacobson, Verlinde, Boyle, Turok, Penrose, Feynman</p>
  </div>
</div>

<!-- MAIN SITE CONTENT -->
<div class="main-site" id="mainSite">

<header>
<h1>Relational Drainage Theory</h1>
<p class="subtitle">A Synthesis and Extension of Established Physics Frameworks</p>
<p class="authors">By Andrew Craton | January 2026</p>
<p class="version">Version 2.5 — Built upon the work of Boyle, Turok, Jacobson, Verlinde, Penrose, Feynman, and the ultrafinitist tradition</p>
</header>

<!-- Tab Navigation -->
<nav class="tab-nav">
  <button class="tab-btn active" data-tab="guide">Simple Guide</button>
  <button class="tab-btn" data-tab="intro">Introduction</button>
  <button class="tab-btn" data-tab="framework">Framework</button>
  <button class="tab-btn" data-tab="physics">Physics</button>
  <button class="tab-btn" data-tab="evidence">Evidence</button>
  <button class="tab-btn" data-tab="glossary">Glossary</button>
  <button class="tab-btn" data-tab="journey">Visual Journey</button>
  <button class="tab-btn" data-tab="innovations">Innovations</button>
</nav>

<!-- TAB 0: SIMPLE GUIDE (Lay Reader) -->
<div class="tab-content active" id="guide">

<div class="epigraph">
"I saw the angel in the marble and carved until I set him free."<br>
— Michelangelo (attributed)
</div>

<section>
<h2>The David Analogy: Understanding RDT</h2>

<p>Imagine Michelangelo standing before a block of Carrara marble. He famously said that David was already inside the stone — he simply removed what wasn't David. This beautiful idea captures the essence of Relational Drainage Theory.</p>

<p><strong>RDT rests on exactly four foundations.</strong> Everything else — time, gravity, quantum mechanics — follows from these four. This page explains each foundation using a single analogy: the marble, the grain, the sculpting, and the mirror.</p>

<div class="boxed" style="background: #f0f8ff;">
<strong>The Framework:</strong> 4 foundational ideas → unified connections across physics.<br>
No equations here — just the marble and the chisel.
</div>
</section>

<section>
<h3>Foundation 1: The Marble Block (Finite Totality)</h3>

<div class="credit-box" style="border-left: 4px solid #8e44ad;">
<h4>F1 — The Block Contains Everything, But Has Edges</h4>
<p>Imagine a block of marble so vast it contains every possible sculpture — not just David, but every statue that could ever be carved. Every arrangement of atoms, every possible configuration of reality, is already "in there."</p>
<p>But here's the key: the block is <em>finite</em>. Unimaginably large, yes — but it has edges. There's a lot of marble, but not an infinite amount. You could, in principle, count every grain.</p>
<p><strong>In RDT:</strong> This is Ω<sub>real</sub> — the set of all possible configurations. We can even estimate how many: about 10^(10^122) configurations. That's more than you could ever count, but it's still a number, not infinity.</p>
</div>

<p><strong>What follows from F1:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>No actual infinities — "infinity" just means "the whole block"</li>
<li>Every configuration already exists — nothing is created or destroyed</li>
<li>Reality has a "grain size" — you can't subdivide forever</li>
</ul>
</section>

<section>
<h3>Foundation 2: The Grain (Metric Structure)</h3>

<div class="credit-box" style="border-left: 4px solid #e74c3c;">
<h4>F2 — The Marble Has Internal Structure</h4>
<p>The marble isn't uniform mush — it has grain. The grain determines which cuts are possible, which forms can emerge, what "nearby" means. You can't just jump from any point to any other point; you have to follow the structure.</p>
<p>This grain defines <em>adjacency</em>: which parts of the marble are close to which other parts. Every physical transition — every moment flowing into the next — respects this grain.</p>
<p><strong>In RDT:</strong> Ω<sub>real</sub> has a metric structure. Configurations aren't floating randomly; they're connected in a vast web of "nearby" relationships. This web is what makes physics possible.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #e74c3c;">
<h4>Why π Emerges (Not Encoded)</h4>
<p>Here's something beautiful: you don't need to "put" π into the marble. If the grain allows any curved paths at all — any circles, any rotations, any cycles — then π <em>automatically appears</em>.</p>
<p>Think about it: if you carve a circle in the marble, the ratio of its edge to its width is π. You didn't add π; the geometry of curves <em>is</em> π. The marble's grain contains π because curves exist.</p>
<p><strong>In RDT:</strong> π isn't mysteriously "encoded" in reality. π <em>emerges</em> from any structure with rotational degrees of freedom. This is standard mathematics (not an RDT discovery): any metric space with cycles necessarily involves π. That's why π appears everywhere in physics — it has to.</p>
</div>

<div class="boxed" style="margin-top: 1.5rem;">
<strong>π is not put into the universe.<br>π emerges from any universe with curves.</strong>
</div>

<p><strong>What follows from F2:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>π appears everywhere (geometric necessity)</li>
<li>Only adjacent configurations can transition to each other</li>
<li>All pairs of configurations are distinguishable (the grain is fine enough)</li>
</ul>
</section>

<section>
<h3>Foundation 3: The Sculpting IS Time (Traversal = Time)</h3>

<div class="credit-box" style="border-left: 4px solid #3498db;">
<h4>F3 — Sculpting Doesn't Happen "In" Time — Sculpting IS Time</h4>
<p>From Michelangelo's perspective, he experiences time as the sequence of chisel strikes — first this cut, then that one, then the next. Time isn't a separate container that "holds" the sculpting. The sequence of cuts <em>is</em> what time feels like from inside.</p>
<p>This is a subtle but crucial point: we don't experience time and <em>also</em> move through configurations. Our movement through configurations <em>is</em> the experience of time. They're the same thing described two ways.</p>
<p><strong>In RDT:</strong> Time ≡ Traversal. This isn't a metaphor; it's a definitional identity. "Now" is wherever you are in the marble. "Past" is where you've been. "Future" is where you're going. There's no external clock — the journey itself is time.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #3498db;">
<h4>You Can Only Take One Path</h4>
<p>The chisel can't teleport from David's toe to his eye in one strike. Each cut connects to the previous one. And when you make a cut, you take <em>that</em> path — the other possible cuts are still there in the marble, just not the route you traveled.</p>
<p><strong>In RDT:</strong> This is why there's no mysterious "wave function collapse." You just take one path. The other paths still exist — they're real configurations in Ω<sub>real</sub> — but they're not <em>your</em> path.</p>
</div>

<p><strong>What follows from F3:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>Time IS traversal (not two separate things)</li>
<li>"Now" = current position in configuration space</li>
<li>No collapse needed — you simply take one path among many</li>
<li>Frequency = how often you encounter cyclic structure along your path</li>
</ul>
</section>

<section>
<h3>Foundation 4: The Klein Bottle (CPT Symmetry)</h3>

<div class="credit-box" style="border-left: 4px solid #27ae60;">
<h4>F4 — The Block Is a Klein Bottle</h4>
<p>Remember those impossible bottles where the inside connects to the outside? That's a Klein bottle — a surface with no true inside or outside. They're the same surface, connected through a twist.</p>
<p>The marble block isn't split by a mirror. <strong>It's a Klein bottle.</strong> What looks like "two halves" (M⁺ and M⁻) are actually <em>one continuous surface</em> that passes through itself. The "mirror" is where the surface intersects itself — the twist that connects inside to outside.</p>
<p><strong>In RDT:</strong> There is only ONE universe — a 4D Klein bottle. What we call M⁺ (our universe) and M⁻ (the "anti-universe") are just perspectives on this single structure. Like asking which side of a Möbius strip you're on — there's only one side.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #27ae60;">
<h4>The Universe Has No Outside</h4>
<p>Here's the profound resolution: "What's outside the universe?" is a malformed question. A Klein bottle has no outside. Inside IS outside — they're the same surface.</p>
<p>The universe is <strong>finite</strong> (bounded configurations) yet has <strong>no boundary</strong> (closed surface) and <strong>no outside</strong> (non-orientable). The question dissolves, like asking "what's north of the North Pole?"</p>
</div>

<div class="credit-box" style="border-left: 4px solid #27ae60;">
<h4>Gravity Flows Through the Hyperbolic Vortex Lattice</h4>
<p>At the O-plane Σ, vortex tunnels form a <strong>hyperbolic lattice</strong> — a fractal structure with negative curvature inherited from the O-plane tension. Entropy drains through this lattice.</p>
<p><strong>In RDT:</strong> What we call "gravity" is this drainage — entropy flowing through the hyperbolic vortex lattice at Σ. The 4π factor is the flat-space projection of this underlying hyperbolic geometry (Gauss-Bonnet).</p>
</div>

<p><strong>What follows from F4:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>One universe (T⁴/ℤ₂ orientifold) with two dual descriptions (M⁺/M⁻)</li>
<li>The boundary paradox resolved: finite, no boundary, no outside</li>
<li>Σ is the O-plane locus — fixed points of ℤ₂ with hyperbolic vortex lattice</li>
<li>Gravity emerges as drainage through the vortex lattice</li>
<li>The 4π factor = flat-space projection of hyperbolic lattice (Gauss-Bonnet)</li>
<li>G derived from T⁴/ℤ₂ topology: G = ℏc/(m_H² · π⁶⁸)</li>
</ul>
</section>

<section>
<h3>What Follows from 4 Foundations</h3>

<p>Here's the framework: these four foundations provide a unified language connecting quantum mechanics, gravity, cosmology, and time. Some results are derived, some adopt external physics (Jacobson, Verlinde, Gleason), some are proposed ansätze.</p>

<div class="boxed">
<strong>From F1 + F2 (Finite Block with Grain):</strong><br>
• Quantum superposition = multiple nearby configurations<br>
• Born rule |ψ|² uniqueness (Gleason); mechanism requires additional assumptions<br>
• Finite path sums (well-defined; divergence elimination is nuanced)<br>
• Entanglement = configurations that are "near" in the grain despite being far apart in space<br><br>

<strong>From F2 + F4 (Grain + Mirror):</strong><br>
• Gravity = thermodynamic equilibration (Jacobson, Verlinde)<br>
• Dark energy evolution w(z) from entropy dynamics<br>
• Cyclic cosmology — requires Drainage Conservation axiom beyond CPT<br><br>

<strong>From F3 (Sculpting = Time):</strong><br>
• Arrow of time = direction of your traversal<br>
• Frequency = rate of hitting cyclic structure<br>
• No "collapse" — you just take one path
</div>
</section>

<section>
<h3>Tesla's Secret: Energy, Frequency, and Vibration</h3>

<div class="epigraph" style="border: 2px solid #9b59b6; background: #f9f4fc; padding: 1.5rem; border-radius: 8px;">
"If you want to find the secrets of the universe, think in terms of energy, frequency and vibration."<br>
— Nikola Tesla
</div>

<p>Tesla's famous quote captures something profound. In RDT, these three concepts aren't separate phenomena — they're all aspects of traversal through π-structured configuration space.</p>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Energy: The Capacity to Move Through the Marble</h4>
<p><strong>The Analogy:</strong> Energy is like the sculptor's strength — the capacity to make the next chisel strike. Without energy, the chisel hovers but cannot move. Energy doesn't create possibilities; it enables traversal through possibilities that already exist.</p>
<p><strong>In RDT:</strong> Energy is not a "stuff" that flows through space. Energy is the capacity for traversal — the ability to move from one configuration to an adjacent one. A particle with more energy can traverse more of configuration space, reach more distant adjacencies. $E = h\nu$ connects energy directly to how rapidly you encounter π-structure.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Frequency: The Rate of Encountering π</h4>
<p><strong>The Analogy:</strong> As Michelangelo carves, his chisel encounters curved surfaces (π-structure) at different rates. Carving David's smooth thigh = low frequency. Carving his intricate curls = high frequency. The "frequency" is how often the grain's curves appear along the path.</p>
<p><strong>In RDT:</strong> Frequency is literally the rate of hitting π-adjacencies during traversal. Light is "high frequency" because the electromagnetic traversal encounters π-structured transitions very rapidly. Sound is lower frequency — the same π-structure, encountered more slowly. All frequencies are the same thing at different rates: traversal recognizing π.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Vibration: Oscillatory Traversal</h4>
<p><strong>The Analogy:</strong> Imagine the chisel doesn't move in a straight line, but oscillates back and forth as it carves — like carving a wave pattern into the marble. The chisel moves forward, but it's also cycling through a repeating pattern. This oscillation IS the vibration.</p>
<p><strong>In RDT:</strong> Vibration is not "something shaking." Vibration is a traversal pattern that returns to similar configurations cyclically. An electron "vibrates" because its traversal through configuration space follows an oscillatory path — it keeps revisiting similar π-structured adjacencies. The vibration IS the traversal pattern.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Why These Three Are Fundamental</h4>
<p><strong>The Analogy:</strong> To sculpt anything, you need: (1) the strength to strike (energy), (2) how often you hit the grain's curves (frequency), and (3) the pattern of your movement (vibration). These aren't three separate things — they're three aspects of the single act of sculpting.</p>
<p><strong>In RDT:</strong> Tesla was right, but deeper than he knew. Energy, frequency, and vibration are fundamental because they're the three faces of traversal through π-structure:</p>
<ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li><strong>Energy</strong> = capacity for traversal</li>
<li><strong>Frequency</strong> = rate of encountering π</li>
<li><strong>Vibration</strong> = the cyclic pattern of the traversal itself</li>
</ul>
<p style="margin-top: 1rem;">Everything that exists is a traversal. Every traversal has energy (capacity), frequency (π-encounter rate), and vibration (pattern). There is nothing else.</p>
</div>

<div class="boxed" style="background: #f9f4fc;">
<strong>Tesla's Insight Decoded:</strong><br><br>
Energy = how far you can traverse<br>
Frequency = how fast you hit π<br>
Vibration = the shape of your path<br><br>
<em>The universe doesn't "have" energy, frequency, and vibration.<br>
The universe IS energy, frequency, and vibration — which is to say,<br>
the universe is traversal through the marble's grain.</em>
</div>
</section>

<section>
<h3>The Summary: 4 Foundations → Everything</h3>

<div class="boxed">
<strong>F1 — The Block (Finite Totality):</strong><br>
All possible configurations already exist — vast but finite, about 10^(10^122) of them.<br><br>

<strong>F2 — The Grain (Metric Structure):</strong><br>
The block has internal structure defining what's "nearby." π emerges from any curved paths.<br><br>

<strong>F3 — The Sculpting (Traversal = Time):</strong><br>
Time IS the journey through the block. You take one path; others remain.<br><br>

<strong>F4 — The Mirror (CPT Symmetry):</strong><br>
Two mirrored halves share a boundary. Flow between them is gravity.
</div>

<p style="font-size: 1.1rem; margin-top: 1.5rem;"><strong>These four ideas form a framework</strong> connecting: time, quantum mechanics, gravity, dark energy, the arrow of time, the Born rule, entanglement, cyclic cosmology. Some are derived, some adopt external results (Jacobson, Verlinde, Gleason), some are proposed formalisms.</p>

<div class="boxed" style="background: #f0f8ff; margin-top: 1.5rem;">
<strong>The Core Insight:</strong><br><br>
David was always in the marble.<br>
The grain allows curves, so π emerges.<br>
Sculpting is time, seen from inside.<br>
The mirror creates flow, which is gravity.<br><br>
<em>We are not observers of the universe.<br>
We are the universe experiencing itself — one chisel strike at a time.</em>
</div>
</section>

<section>
<h3>Quantum Mechanics: Many Cuts Are "Near"</h3>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Superposition: Many Cuts Could Be Next</h4>
<p>The chisel hovers. Multiple points on the marble are equally good next strikes — they're all "adjacent" to where you are now. Until you actually strike, all these possibilities are real and nearby.</p>
<p><strong>In RDT:</strong> "Superposition" isn't a particle being in multiple places. It's that multiple configurations are adjacent to your current state. The "wave function" describes what's nearby in configuration space.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>The Born Rule: The Only Way to Count</h4>
<p>When multiple cuts are possible, how do you calculate which one is most likely? It turns out there's only ONE consistent way to assign probabilities to the possibilities — and that's |ψ|², the Born rule.</p>
<p><strong>In RDT:</strong> We don't derive the Born rule from some special mechanism. Gleason's theorem (1957) proves that for ANY finite set of possibilities with the structure of quantum mechanics, |ψ|² is the ONLY consistent probability rule. It's not mysterious — it's mathematically forced.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #9b59b6;">
<h4>Entanglement: Distant Points That Are "Near" in the Grain</h4>
<p>Sometimes two points on opposite sides of the marble are structurally connected — carving one constrains how the other must be carved, even though they're far apart spatially. They're "adjacent" in the marble's grain, not in 3D space.</p>
<p><strong>In RDT:</strong> Entangled particles aren't communicating faster than light. They're configurations that are adjacent in Ω<sub>real</sub> despite being far apart in physical space. No spooky action — just a different notion of "nearby."</p>
<p><strong>Novel prediction:</strong> There might be a maximum "distance" in the grain beyond which entanglement is impossible. Standard quantum mechanics has no such limit.</p>
</div>
</section>

</div>

<!-- TAB 1: INTRODUCTION -->
<div class="tab-content" id="intro">

<section id="disclaimer" style="background: #fff3cd; border: 1px solid #ffc107; padding: 1rem; border-radius: 6px; margin-bottom: 2rem;">
<h3 style="margin-top: 0; color: #856404;">Important Notice on Attribution</h3>
<p style="margin-bottom: 0;"><strong>RDT is not an original theory.</strong> It is a synthesis that unifies, reinterprets, and extends ideas from multiple established research programs in physics and philosophy of mathematics. The core physical mechanisms — CPT-symmetric cosmology, thermodynamic gravity, entropic forces, cyclic cosmology, and ultrafinitism — were developed by the researchers credited in this section. RDT's contribution is the specific synthesis, the π-encoding interpretation, and certain novel extensions. Users should cite the original authors for foundational claims.</p>
</section>

<!-- SECTION I: ORIGINS -->
<section id="origins">
<h2>I. Theoretical Origins</h2>

<p>RDT synthesizes ideas from seven major research traditions. This section explicitly identifies what comes from where.</p>

<table>
<tr><th>RDT Component</th><th>Primary Source</th><th>Original Author(s)</th><th>Date</th></tr>
<tr><td>Static block universe / Eternalism</td><td>Spacetime physics</td><td>Parmenides, Minkowski, Putnam, Rietdijk</td><td>~500 BCE, 1908, 1967</td></tr>
<tr><td>Dual CPT-symmetric manifolds (A13–14)</td><td>CPT-Symmetric Universe</td><td><strong>Latham Boyle & Neil Turok</strong></td><td>2018</td></tr>
<tr><td>Gravity as thermodynamic equilibrium (A17)</td><td>Thermodynamic gravity</td><td><strong>Ted Jacobson</strong></td><td>1995</td></tr>
<tr><td>Entropic gravity / drainage metaphor</td><td>Emergent gravity</td><td><strong>Erik Verlinde</strong></td><td>2010, 2016</td></tr>
<tr><td>Cyclic cosmology (A20)</td><td>Conformal Cyclic Cosmology</td><td><strong>Roger Penrose</strong></td><td>2010</td></tr>
<tr><td>Path integral formalism (QM section)</td><td>Sum over histories</td><td><strong>Richard Feynman</strong></td><td>1948</td></tr>
<tr><td>Finite totality / No actual infinity (A1, A3)</td><td>Ultrafinitism</td><td>Esenin-Volpin, <strong>Zeilberger</strong>, <strong>Wildberger</strong></td><td>1959–present</td></tr>
<tr><td>Time as traversal through configurations</td><td>Process philosophy / Block universe</td><td>Whitehead, various</td><td>1929+</td></tr>
</table>

<h3>What RDT Adds (Novel Extensions)</h3>
<table>
<tr><th>Novel Claim</th><th>Status</th></tr>
<tr><td>π encodes adjacency structure of configuration space (A5–A6)</td><td>Conjectural</td></tr>
<tr><td>Total entropy conservation across dual universes (A18)</td><td>Extension of Boyle-Turok</td></tr>
<tr><td>Time ≡ Traversal as formal identity (A9)</td><td>Interpretive synthesis</td></tr>
<tr><td>Born rule from π-weighted path density (A23)</td><td>Speculative derivation</td></tr>
<tr><td>ℏ = Vol(Ω)/N (A24)</td><td>Speculative</td></tr>
<tr><td>Unified framework combining all above</td><td>Synthesis</td></tr>
</table>
</section>

<!-- SECTION X: CREDITS -->
<section id="credits">
<h2>Primary Sources & Credits</h2>

<p><strong>RDT would not exist without the foundational work of the following researchers. These are the true originators of the core ideas; RDT merely synthesizes and extends their contributions.</strong></p>

<div class="credit-box" style="border-left: 4px solid #c0392b;">
<h4>Latham Boyle & Neil Turok — CPT-Symmetric Universe (2018–2024)</h4>
<p><strong>FOUNDATIONAL to RDT.</strong> The entire dual-manifold structure (A13–14) is directly adopted from their work.</p>
<p><strong>Their result:</strong> The universe respects CPT symmetry globally. Our universe (time forward, matter-dominated) is paired with an "anti-universe" (time backward, antimatter-dominated) on the other side of the Big Bang. This naturally explains dark matter as stable right-handed neutrinos.</p>
<p><strong>RDT's extension:</strong> Total entropy conservation across manifolds (A18); drainage current formalism.</p>
<p><em>Boyle, L., Finn, K., Turok, N. "CPT-Symmetric Universe." Phys. Rev. Lett. 121, 251301 (2018).</em><br>
<em>Boyle, L. & Turok, N. "The Big Bang, CPT, and Neutrino Dark Matter." Annals of Physics (2022).</em></p>
</div>

<div class="credit-box" style="border-left: 4px solid #c0392b;">
<h4>Ted Jacobson — Thermodynamic Gravity (1995, 2016)</h4>
<p><strong>FOUNDATIONAL to RDT.</strong> The claim that gravity is not a fundamental force but an equilibrium condition (A17) comes directly from Jacobson.</p>
<p><strong>His result:</strong> The Einstein field equations can be derived from δQ = TδS applied to all local Rindler horizons. Gravity is an equation of state, not a fundamental interaction.</p>
<p><strong>RDT's extension:</strong> Reinterpretation as "drainage" between dual manifolds; vortex formalism.</p>
<p><em>Jacobson, T. "Thermodynamics of Spacetime: The Einstein Equation of State." Phys. Rev. Lett. 75, 1260 (1995).</em></p>
</div>

<div class="credit-box" style="border-left: 4px solid #c0392b;">
<h4>Erik Verlinde — Entropic/Emergent Gravity (2010, 2016)</h4>
<p><strong>FOUNDATIONAL to RDT.</strong> The "drainage" metaphor and entropic force interpretation derive from Verlinde.</p>
<p><strong>His result:</strong> Gravity as entropic force: F = T(ΔS/Δx). Dark matter phenomena explained by volume-law entropy in de Sitter space. Predicts anomalies at acceleration scale a₀ ≈ cH₀.</p>
<p><strong>RDT's extension:</strong> Formalization of drainage rate Γ; connection to dual-manifold entropy differential.</p>
<p><em>Verlinde, E. "On the Origin of Gravity and the Laws of Newton." JHEP 1104:029 (2011).</em><br>
<em>Verlinde, E. "Emergent Gravity and the Dark Universe." SciPost Phys. 2, 016 (2017).</em></p>
</div>

<div class="credit-box" style="border-left: 4px solid #c0392b;">
<h4>Roger Penrose — Conformal Cyclic Cosmology (2010–2025)</h4>
<p><strong>FOUNDATIONAL to RDT.</strong> The cyclic structure (A20) and CMB observational program derive from Penrose's CCC.</p>
<p><strong>His result:</strong> Universe undergoes infinite cycles (aeons). End of one aeon conformally maps to beginning of next. Predicts CMB anomalies ("Hawking points").</p>
<p><strong>RDT's extension:</strong> Entropy inversion mechanism; drainage reversal at critical differential.</p>
<p><em>Penrose, R. "Cycles of Time: An Extraordinary New View of the Universe." Bodley Head (2010).</em></p>
</div>

<div class="credit-box" style="border-left: 4px solid #c0392b;">
<h4>Ultrafinitist Tradition — Finite Mathematics</h4>
<p><strong>FOUNDATIONAL to RDT.</strong> The finite substrate (A1) and infinity elimination (A3) come directly from this tradition.</p>
<p><strong>Key figures:</strong></p>
<ul>
<li><strong>Alexander Esenin-Volpin</strong> (1959–2016): Pioneered formal ultrafinitist mathematics</li>
<li><strong>Doron Zeilberger</strong> (Rutgers): "Real analysis is a degenerate case of discrete analysis"</li>
<li><strong>Norman Wildberger</strong> (UNSW): Rational trigonometry; argues infinity should be expelled from mathematics</li>
</ul>
<p><strong>RDT's extension:</strong> Application to physics; π-termination claim; ℏ as granularity.</p>
</div>

<div class="credit-box" style="border-left: 4px solid #2980b9;">
<h4>Richard Feynman — Path Integral Formalism (1948)</h4>
<p><strong>Background for RDT's QM section.</strong> The sum-over-paths formalism that RDT finitizes.</p>
<p><em>Feynman, R.P. "Space-Time Approach to Non-Relativistic Quantum Mechanics." Rev. Mod. Phys. 20, 367 (1948).</em></p>
</div>

<div class="credit-box" style="border-left: 4px solid #2980b9;">
<h4>Block Universe / Eternalism — Philosophical Background</h4>
<p><strong>Background for RDT's ontology.</strong> The static totality conception.</p>
<p><strong>Key figures:</strong> Parmenides (~500 BCE), Hermann Minkowski (1908), Hilary Putnam (1967), C.W. Rietdijk (1966).</p>
</div>

<div class="credit-box" style="border-left: 4px solid #27ae60;">
<h4>DESI Collaboration — Dark Energy Observations (2024–2025)</h4>
<p><strong>Empirical support.</strong> Evidence for time-evolving dark energy that aligns with RDT predictions.</p>
<p><strong>Result:</strong> w ≠ −1 at 2–3σ; w₀ ≈ −0.8 to −1.0 with w<sub>a</sub> ≠ 0.</p>
<p><em>DESI Collaboration. "DESI 2024 VI: Cosmological Constraints from BAO." arXiv (2024).</em></p>
</div>
</section>

</div>

<!-- TAB 2: FRAMEWORK -->
<div class="tab-content" id="framework">

<div class="epigraph">
"Everything that can exist, exists — finitely, statically, now.<br>
Time is not a container; it is a path.<br>
π is the shape of relation itself."
</div>

<!-- SECTION II: THE FOUR FOUNDATIONS -->
<section id="foundations">
<h2>II. The Four Foundations</h2>

<p><em>RDT rests on exactly four foundational axioms. Everything else — time, gravity, quantum mechanics, cosmology — follows as theorems.</em></p>

<div class="boxed" style="background: #f0f8ff;">
<strong>The Framework Principle:</strong> A framework is strong when it unifies diverse phenomena with few assumptions. RDT connects quantum mechanics, gravity, cosmology, and time via 4 foundations — some results derived, some adopted, some proposed.
</div>

<!-- Configuration Space Visualization -->
<div class="physics-viz" style="height: 130px;">
  <div class="config-space-viz">
    <svg viewBox="0 0 200 100" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
      <!-- Configuration dots -->
      <circle cx="30" cy="50" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" repeatCount="indefinite"/>
      </circle>
      <circle cx="60" cy="30" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="0.2s" repeatCount="indefinite"/>
      </circle>
      <circle cx="90" cy="45" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="0.4s" repeatCount="indefinite"/>
      </circle>
      <circle cx="120" cy="65" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="0.6s" repeatCount="indefinite"/>
      </circle>
      <circle cx="150" cy="40" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="0.8s" repeatCount="indefinite"/>
      </circle>
      <circle cx="170" cy="70" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="1s" repeatCount="indefinite"/>
      </circle>
      <circle cx="45" cy="75" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="1.2s" repeatCount="indefinite"/>
      </circle>
      <circle cx="80" cy="80" r="4" fill="#8b5cf6" opacity="0.6">
        <animate attributeName="opacity" values="0.4;0.8;0.4" dur="2s" begin="1.4s" repeatCount="indefinite"/>
      </circle>
      <!-- Active traversal point -->
      <circle r="6" fill="#f5f5dc">
        <animate attributeName="cx" values="30;60;90;120;150;170;150;120;90;60;30" dur="8s" repeatCount="indefinite"/>
        <animate attributeName="cy" values="50;30;45;65;40;70;40;65;45;30;50" dur="8s" repeatCount="indefinite"/>
      </circle>
      <!-- Connections -->
      <line x1="30" y1="50" x2="60" y2="30" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
      <line x1="60" y1="30" x2="90" y2="45" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
      <line x1="90" y1="45" x2="120" y2="65" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
      <line x1="120" y1="65" x2="150" y2="40" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
      <line x1="150" y1="40" x2="170" y2="70" stroke="#06b6d4" stroke-width="1" opacity="0.3"/>
    </svg>
  </div>
  <span class="physics-viz-label">Ω_real: finite configuration space with traversal γ(τ)</span>
</div>

<h3>Foundation 1: Finite Totality</h3>

<div class="axiom">
<strong>F1 (Finite Totality).</strong> There exists a finite set <a href="#sym-Omega" class="sym-link" title="View in Glossary">Ω</a><sub>real</sub> containing all possible configurations. $$|\Omega_{\text{real}}| = N \approx 10^{10^{122}}$$
<em>Sources: Ultrafinitism (Zeilberger, Wildberger), Bekenstein bound, Holographic principle.</em>
</div>

<p><strong>Why accept F1?</strong></p>
<ul style="margin-left: 1.5rem;">
<li>The Bekenstein bound proves maximum entropy (hence maximum configurations) in any finite region</li>
<li>The holographic principle: 3D physics encoded on 2D boundary with finite bits</li>
<li>No infinite quantity has ever been observed or measured</li>
<li>All computation, all physics, all measurement is finite</li>
</ul>

<p><em>Derivation follows from the Bekenstein bound (1981) and holographic principle ('t Hooft, Susskind).</em></p>

<h3>Foundation 2: Metric Structure</h3>

<div class="axiom">
<strong>F2 (Metric Structure).</strong> Ω<sub>real</sub> has an adjacency metric: $$d: \Omega_{\text{real}} \times \Omega_{\text{real}} \to \mathbb{R}_{\geq 0}$$ where <a href="#sym-d" class="sym-link" title="View in Glossary">d(σ, σ')</a> defines the "distance" between configurations <a href="#sym-sigma" class="sym-link" title="View in Glossary">σ</a> and σ'.
<em>Source: Standard mathematics; physical necessity for transition.</em>
</div>

<!-- F2 Metric Structure Visualization -->
<div class="physics-viz" style="height: 120px;">
  <svg viewBox="0 0 300 100" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- Configuration nodes -->
    <circle cx="50" cy="50" r="8" fill="#8b5cf6" opacity="0.8">
      <animate attributeName="r" values="8;10;8" dur="2s" repeatCount="indefinite"/>
    </circle>
    <circle cx="120" cy="35" r="8" fill="#8b5cf6" opacity="0.8"/>
    <circle cx="150" cy="70" r="8" fill="#06b6d4" opacity="0.8"/>
    <circle cx="220" cy="45" r="8" fill="#8b5cf6" opacity="0.8"/>
    <circle cx="260" cy="65" r="8" fill="#ec4899" opacity="0.8"/>
    <!-- Distance lines with labels -->
    <line x1="58" y1="50" x2="112" y2="35" stroke="#f5f5dc" stroke-width="1" stroke-dasharray="4,2">
      <animate attributeName="opacity" values="0.3;0.8;0.3" dur="3s" repeatCount="indefinite"/>
    </line>
    <line x1="128" y1="35" x2="142" y2="70" stroke="#f5f5dc" stroke-width="1" stroke-dasharray="4,2">
      <animate attributeName="opacity" values="0.3;0.8;0.3" dur="3s" begin="0.5s" repeatCount="indefinite"/>
    </line>
    <line x1="158" y1="70" x2="212" y2="45" stroke="#f5f5dc" stroke-width="1" stroke-dasharray="4,2">
      <animate attributeName="opacity" values="0.3;0.8;0.3" dur="3s" begin="1s" repeatCount="indefinite"/>
    </line>
    <!-- Distance labels -->
    <text x="85" y="35" fill="#f5f5dc" font-size="9" font-family="monospace">d=2.3</text>
    <text x="125" y="60" fill="#f5f5dc" font-size="9" font-family="monospace">d=4.1</text>
    <text x="180" y="50" fill="#f5f5dc" font-size="9" font-family="monospace">d=3.7</text>
    <!-- Labels -->
    <text x="50" y="70" fill="#888" font-size="8" text-anchor="middle">σ₁</text>
    <text x="120" y="25" fill="#888" font-size="8" text-anchor="middle">σ₂</text>
    <text x="150" y="88" fill="#888" font-size="8" text-anchor="middle">σ₃</text>
  </svg>
  <span class="physics-viz-label">d(σᵢ, σⱼ) defines adjacency — which configs are "near"</span>
</div>

<p><strong>Why accept F2?</strong></p>
<ul style="margin-left: 1.5rem;">
<li>Physical transitions require a notion of "nearby" — you can't jump from any state to any other</li>
<li>All physical laws express local relationships (derivatives, field equations)</li>
<li>Metric structure is the minimal requirement for dynamics</li>
</ul>

<div class="credit-box" style="border-left: 4px solid #06b6d4; background: rgba(6,182,212,0.05); margin: 1.5rem 0;">
<h4 style="color: #06b6d4;">Compatibility: Quantum Metric Tensor</h4>
<p>The quantum metric tensor g<sub>μν</sub> — measuring distance between quantum states — was directly measured in black phosphorus (2025). This confirms standard quantum geometry (Provost & Vallee, 1980).</p>
<p>The quantum metric tensor emerges from the Ω-metric structure. The standard derivation (Provost-Vallee 1980) is a special case of the general Ω-metric formalism.</p>
<p style="margin-bottom: 0;"><a href="innovations/quantum-metric-tensor.html" style="color: #06b6d4;">→ See compatibility analysis</a></p>
</div>

<p><em>Any dynamical theory requires a notion of proximity between states; the metric axiom formalizes this requirement.</em></p>

<h3>Foundation 3: Traversal ≡ Time</h3>

<div class="definition">
<strong>D1 (Traversal Identity).</strong> The ordering parameter τ of paths γ(τ) through Ω IS physical time: $$\gamma: \tau \to \Omega_{\text{real}}$$ where <a href="#sym-gamma" class="sym-link" title="View in Glossary">γ</a> is the traversal path and <a href="#sym-tau" class="sym-link" title="View in Glossary">τ</a> IS physical time. This is a <strong>definitional identity</strong> mapping RDT's mathematical structure to physics' time coordinate, analogous to Einstein's proper time along worldlines.
<em>Sources: General Relativity (proper time), Block universe physics.</em>
</div>

<p><strong>Note on status:</strong> D1 is a genuine <em>definition</em>: it maps the mathematical ordering parameter τ to the physical concept "time." No metaphysical claims about consciousness or experience are made. RDT is about physical reality, not perception.</p>

<!-- F3 Traversal Mapping Visualization -->
<div class="physics-viz" style="height: 110px;">
  <svg viewBox="0 0 350 90" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- τ ordering parameter (left side) -->
    <text x="30" y="20" fill="#888" font-size="10">τ (ordering)</text>
    <line x1="30" y1="30" x2="30" y2="75" stroke="#8b5cf6" stroke-width="2"/>
    <circle cx="30" cy="35" r="4" fill="#8b5cf6" opacity="0.5"/>
    <circle cx="30" cy="50" r="4" fill="#8b5cf6" opacity="0.7"/>
    <circle cx="30" cy="65" r="5" fill="#f5f5dc">
      <animate attributeName="cy" values="35;50;65;50;35" dur="4s" repeatCount="indefinite"/>
    </circle>
    <!-- Arrow showing mapping -->
    <path d="M50,50 C80,50 80,50 110,50" stroke="#06b6d4" stroke-width="2" fill="none" marker-end="url(#arrowhead)">
      <animate attributeName="stroke-dasharray" values="0,100;60,0" dur="2s" repeatCount="indefinite"/>
    </path>
    <text x="80" y="42" fill="#06b6d4" font-size="10">γ</text>
    <defs>
      <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
        <polygon points="0 0, 10 3.5, 0 7" fill="#06b6d4"/>
      </marker>
    </defs>
    <!-- Ω_real configuration space (right side) -->
    <text x="220" y="20" fill="#888" font-size="10">Ω_real</text>
    <ellipse cx="220" cy="52" rx="90" ry="35" fill="none" stroke="#8b5cf6" stroke-width="1" opacity="0.5"/>
    <circle cx="160" cy="45" r="5" fill="#8b5cf6" opacity="0.4"/>
    <circle cx="190" cy="60" r="5" fill="#8b5cf6" opacity="0.4"/>
    <circle cx="220" cy="40" r="5" fill="#8b5cf6" opacity="0.4"/>
    <circle cx="250" cy="55" r="5" fill="#8b5cf6" opacity="0.4"/>
    <circle cx="280" cy="48" r="5" fill="#8b5cf6" opacity="0.4"/>
    <!-- Current position marker -->
    <circle r="6" fill="#f5f5dc">
      <animate attributeName="cx" values="160;190;220;250;280;250;220;190;160" dur="4s" repeatCount="indefinite"/>
      <animate attributeName="cy" values="45;60;40;55;48;55;40;60;45" dur="4s" repeatCount="indefinite"/>
    </circle>
  </svg>
  <span class="physics-viz-label">γ: τ → Ω — the ordering parameter τ IS physical time</span>
</div>

<p><strong>Why accept F3?</strong></p>
<ul style="margin-left: 1.5rem;">
<li>Experience has temporal order — first this, then that</li>
<li>Each moment of experience corresponds to a configuration</li>
<li>The sequence of moments IS the traversal — no external "time" needed</li>
<li>This dissolves (not solves) the hard problem: experience isn't caused by traversal, it IS traversal</li>
</ul>

<p><em>This identity dissolves the hard problem of time: temporal experience requires no external parameter.</em></p>

<h3>Foundation 4: CPT Symmetry (Klein Bottle Topology)</h3>

<div class="axiom">
<strong>F4 (Global CPT).</strong> The totality respects CPT symmetry: for every configuration σ⁺, there exists a CPT-conjugate σ⁻. $$\text{CPT}: \Omega^+ \leftrightarrow \Omega^-$$ The universe is a <strong>4D Klein bottle</strong> — a single non-orientable structure. What appears as "dual manifolds M⁺ and M⁻" are perspectives on this one surface. The "boundary" <a href="#sym-Sigma-boundary" class="sym-link" title="View in Glossary">Σ</a> is where the Klein bottle passes through itself (self-intersection).
<em>Source: Boyle & Turok CPT cosmology (2018); Klein bottle topology extends the framework.</em>
</div>

<!-- F4 Klein Bottle Visualization -->
<div class="physics-viz" style="height: 140px;">
  <svg viewBox="0 0 320 120" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- Klein bottle outer shape -->
    <ellipse cx="160" cy="60" rx="120" ry="45" fill="none" stroke="#06b6d4" stroke-width="1.5" opacity="0.6"/>
    <!-- Klein bottle neck (passing through) -->
    <path d="M 160 15 Q 200 30, 200 60 Q 200 90, 160 95" fill="none" stroke="#ec4899" stroke-width="1.5" opacity="0.8"/>
    <path d="M 160 15 Q 120 30, 120 55" fill="none" stroke="#ec4899" stroke-width="1.5" opacity="0.5" stroke-dasharray="4,2"/>
    <!-- Self-intersection point Σ -->
    <circle cx="160" cy="60" r="8" fill="#f5f5dc" opacity="0.9">
      <animate attributeName="r" values="8;12;8" dur="2s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.9;1;0.9" dur="2s" repeatCount="indefinite"/>
    </circle>
    <text x="160" y="63" fill="#000" font-size="8" text-anchor="middle" font-weight="bold">Σ</text>
    <!-- M+ label (one perspective) -->
    <text x="70" y="55" fill="#67e8f9" font-size="10" text-anchor="middle">M⁺</text>
    <text x="70" y="67" fill="#67e8f9" font-size="7" text-anchor="middle">(perspective)</text>
    <!-- M- label (same surface, other perspective) -->
    <text x="250" y="55" fill="#f9a8d4" font-size="10" text-anchor="middle">M⁻</text>
    <text x="250" y="67" fill="#f9a8d4" font-size="7" text-anchor="middle">(same surface)</text>
    <!-- CPT arrow showing the twist -->
    <path d="M 100 40 Q 130 25, 160 25 Q 190 25, 220 40" fill="none" stroke="#f5f5dc" stroke-width="1" marker-end="url(#arrowhead)"/>
    <text x="160" y="18" fill="#f5f5dc" font-size="8" text-anchor="middle">CPT twist</text>
    <!-- Arrow marker -->
    <defs>
      <marker id="arrowhead" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto">
        <polygon points="0 0, 6 3, 0 6" fill="#f5f5dc"/>
      </marker>
    </defs>
    <!-- Vortex tunnels at Σ (small circles) -->
    <circle cx="152" cy="55" r="2" fill="#22c55e" opacity="0.8">
      <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" repeatCount="indefinite"/>
    </circle>
    <circle cx="168" cy="55" r="2" fill="#22c55e" opacity="0.8">
      <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" begin="0.3s" repeatCount="indefinite"/>
    </circle>
    <circle cx="155" cy="68" r="2" fill="#22c55e" opacity="0.8">
      <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" begin="0.6s" repeatCount="indefinite"/>
    </circle>
    <circle cx="165" cy="68" r="2" fill="#22c55e" opacity="0.8">
      <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" begin="0.9s" repeatCount="indefinite"/>
    </circle>
    <!-- No outside label -->
    <text x="160" y="112" fill="#888" font-size="8" text-anchor="middle" font-style="italic">No inside/outside — one continuous surface</text>
  </svg>
  <span class="physics-viz-label">Klein bottle: M⁺ and M⁻ are perspectives on ONE surface; Σ is the self-intersection</span>
</div>

<p><strong>Why accept F4 (Klein bottle / orientifold)?</strong></p>
<ul style="margin-left: 1.5rem;">
<li>CPT is the most fundamental symmetry in physics (CPT theorem)</li>
<li>T⁴/ℤ₂ IS an orientifold — established string theory construction</li>
<li>M⁺/M⁻ are dual theories (like T-duality), not separate universes</li>
<li>O-plane Σ provides mechanism for entropy drainage → gravity</li>
<li>4π factor = flat-space projection of hyperbolic vortex lattice (Gauss-Bonnet)</li>
<li>G derived from T⁴/ℤ₂ topology: G = ℏc/(m_H² · π⁶⁸)</li>
</ul>

<p><em>T⁴/ℤ₂ (4-torus quotiented by orientation-reversing involution) is an orientifold. CPT is the ℤ₂ duality transformation relating dual descriptions M⁺ ↔ M⁻.</em></p>

<p><strong>See:</strong> <a href="innovations/klein-bottle-universe.html" style="color: #06b6d4;">The Klein Bottle Universe</a> for full derivation of G and the hierarchy.</p>

<h3>The Derivation Chains</h3>

<p><em>Each result follows from the foundations via the derivation chains below.</em></p>

<div class="dependency-tree">
F1 (Finite Totality)
 ├──► N ≈ 10^(10^122) via Bekenstein bound ✓ (established physics)
 ├──► No actual infinities (∞ → N) ✓ (follows from F1)
 ├──► Hilbert space is N-dimensional ✓ (follows from F1)
 └──► ℏ derivable if L² (area quantum) independently defined (Section IX)

F2 (Metric Structure)
 ├──► π emerges in any metric with cycles ✓ (standard geometry)
 ├──► c_max exists and is finite ✓ (derived); numerical value empirical
 ├──► Adjacency defines valid transitions ✓ (definitional)
 └──► Tensor product structure for composites ✓ (locality requirement)

F1 + F2 (Finite Local Structure)
 ├──► Path integral = finite sum ✓ (well-defined)
 ├──► Superposition = multiple adjacent configurations ✓
 ├──► <strong>Born rule |ψ|² DERIVED</strong> (tensor structure → envariance → |ψ|²)
 ├──► Entanglement = Ω-adjacency despite spatial distance ✓
 └──► d_max: maximum entanglement distance (novel prediction)

F1 + F2 + D1 (Dynamics + Entanglement Equilibrium)
 ├──► Information-preserving traversal → maximal entanglement ✓
 ├──► <strong>Einstein equations CONNECTED</strong> (via Jacobson 2016; RDT motivates entanglement equilibrium)
 ├──► Drainage rate Γ(r) specified via Verlinde acceleration scale a₀
 └──► Quantum metric tensor g_μν ∝ Ω-metric (Provost-Vallee 1980)

D1 (Traversal ≡ Time) — Definition, not axiom
 ├──► Time IS traversal ordering (definitional identity)
 ├──► "Now" = current position γ(τ)
 └──► Lorentzian signature (−,+,+,+) from finite propagation speed (F1+F2)

F4 (CPT Symmetry) + T⁴/ℤ₂ Orientifold
 ├──► Universe is T⁴/ℤ₂ orientifold (established string theory construction) ✓
 ├──► M⁺/M⁻ are DUAL THEORIES (like T-duality), not separate manifolds ✓
 ├──► Σ is O-plane with hyperbolic vortex lattice (4π = flat-space projection) ✓
 ├──► <strong>Arrow of time DERIVED</strong> (entropy increases along surface from Σ)
 ├──► <strong>Entropy conservation DERIVED</strong> = thermodynamic tadpole cancellation
 ├──► <strong>G DERIVED</strong>: G = ℏc/(m_H² · π⁶⁸) from T⁴/ℤ₂ π-geometry
 └──► Hierarchy R = π³⁴ ≈ 10¹⁷ (34 = 32 tesseract edges + 2 twist)

F4 + Holographic Principle
 ├──► <strong>Dark energy w(z) CONSTRAINED</strong> (HDE framework + DESI data)
 ├──► HDE parameter c ~ 0.8-1.2 (fitted, not derived from first principles)
 └──► Cyclic cosmology: entropy max → inversion (extends Penrose CCC)
</div>

<h3>Why π Emerges (Not Encoded)</h3>

<div class="definition">
<strong>Standard Geometry (not novel).</strong> In any metric space admitting cyclic traversals, the ratio of cycle perimeter to diameter converges to π as cycles become smooth. This is a well-known result from Euclidean geometry, not an RDT discovery.
</div>

<!-- Pi Emergence Visualization -->
<div class="physics-viz" style="height: 140px;">
  <svg viewBox="0 0 300 120" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <defs>
      <linearGradient id="piGrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:1" />
        <stop offset="50%" style="stop-color:#06b6d4;stop-opacity:1" />
        <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
      </linearGradient>
    </defs>
    <!-- Polygon approximating circle -->
    <polygon points="150,20 180,28 200,50 195,80 165,100 135,100 105,80 100,50 120,28"
             fill="none" stroke="#8b5cf6" stroke-width="1" opacity="0.4"/>
    <!-- Circle -->
    <circle cx="150" cy="60" r="40" fill="none" stroke="url(#piGrad)" stroke-width="2">
      <animate attributeName="stroke-dasharray" values="0,252;252,0" dur="3s" repeatCount="indefinite"/>
    </circle>
    <!-- Diameter line -->
    <line x1="110" y1="60" x2="190" y2="60" stroke="#f5f5dc" stroke-width="1" stroke-dasharray="4,2"/>
    <!-- Pi symbol -->
    <text x="150" y="65" fill="#f5f5dc" font-size="18" text-anchor="middle" font-family="serif">π</text>
    <!-- Labels -->
    <text x="150" y="110" fill="#888" font-size="10" text-anchor="middle">perimeter / diameter = π</text>
    <!-- Rotating marker -->
    <circle r="4" fill="#f5f5dc">
      <animateMotion dur="3s" repeatCount="indefinite">
        <mpath href="#circPath"/>
      </animateMotion>
    </circle>
    <path id="circPath" d="M150,20 A40,40 0 1,1 149.99,20" fill="none"/>
  </svg>
  <span class="physics-viz-label">π emerges from any metric space with cycles</span>
</div>

<p><em>Proof sketch:</em> A discrete cycle with n vertices on a regular polygon has perimeter/diameter = n·sin(π/n)/(1) → π as n → ∞. For finite but large N, the approximation is exact to measurable precision.</p>

<p><strong>Key insight:</strong> π is not "put into" the structure. π <em>emerges</em> from any geometry with rotational degrees of freedom. This is why π appears everywhere — it's geometrically necessary, not mysteriously encoded.</p>

<h3>Why Born Rule is Unique (Gleason's Theorem)</h3>

<div class="theorem">
<strong>Gleason's Theorem (1957).</strong> On a Hilbert space of dimension ≥ 3, the only probability measure satisfying:
<ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li>Non-negativity: P(E) ≥ 0</li>
<li>Normalization: P(Ω) = 1</li>
<li>Countable additivity for orthogonal projections</li>
</ol>
is given by the Born rule: P(E) = tr(ρE) = |⟨ψ|E|ψ⟩|² for pure states.
</div>

<p><strong>Key insight:</strong> We don't derive the Born rule from path counting. We recognize that for <em>any</em> finite-dimensional quantum system, |ψ|² is the <em>only possible</em> probability rule. This is a mathematical theorem, not a physical assumption.</p>

<h3>Summary: From 3+1 to Connected Results</h3>

<table>
<tr><th>Element</th><th>Type</th><th>Results</th></tr>
<tr><td>F1: Finite Totality</td><td>Axiom</td><td>N quantified via Bekenstein, no infinities, finite Hilbert space</td></tr>
<tr><td>F2: Metric Structure</td><td>Axiom</td><td>π emergence, c existence, adjacency, tensor structure</td></tr>
<tr><td>D1: Traversal ≡ Time</td><td>Definition</td><td>Time identity, now/past/future, Lorentzian signature</td></tr>
<tr><td>F4: CPT Symmetry</td><td>Axiom</td><td>Dual manifolds, boundary, arrow of time, entropy conservation</td></tr>
<tr><td colspan="3"><strong>Combined:</strong> Path integrals, superposition, Born rule, entanglement, Einstein equations (connected), drainage</td></tr>
</table>

<div class="boxed">
$$\boxed{\text{3 Axioms + 1 Definition} \Rightarrow \text{Unified Interpretive Framework}}$$
<strong>Rigor varies by result:</strong> Born rule and arrow of time are mathematically derived; Einstein equations are physically connected via Jacobson; dark energy is empirically constrained via HDE+DESI; Standard Model remains underived.
</div>

</section>

<!-- SECTION III: ONTOLOGY -->
<section id="ontology">
<h2>III. Ontological Framework</h2>

<p><em>This section synthesizes eternalism (block universe) with ultrafinitism. The combination is RDT's interpretive contribution; the individual pieces are established.</em></p>

<div class="definition">
<strong>Configuration Space.</strong> Let Ω<sub>real</sub> denote the totality — the set of all coherent configurations.
</div>

<div class="theorem">
<strong>Static Completeness.</strong> For any configuration σ: $$\sigma \in \Omega_{\text{real}} \text{ eternally}$$ No configuration comes into or out of existence.
</div>

<div class="theorem">
<strong>Infinity Elimination.</strong> Any mathematical statement using ∞ that yields correct predictions remains true under ∞ → N, provided N exceeds measurement precision.
</div>

<div class="corollary">
<strong>No Actual Infinity.</strong> Every apparent infinity is: (1) a finite sum over Ω<sub>real</sub>, (2) a limit that stabilizes before N, or (3) an approximation exact under reinterpretation.
</div>

<div class="boxed">
$$\boxed{\text{There is no infinity. There is only "all of it."}}$$
</div>
</section>

<!-- SECTION IV: STRUCTURE -->
<section id="structure">
<h2>IV. Structural Framework: The π-Blueprint</h2>

<p><em>This section contains RDT's most novel and philosophically significant claims. The π-encoding interpretation (A5–A6) is not found in the source literature and should be considered conjectural — but it is central to the framework.</em></p>

<h3>π is Not Part of the Universe</h3>

<p>A crucial distinction: <strong>π is not a thing within the universe.</strong> π is the blueprint that makes any representational form possible. It is not "in" the static block — it <em>is</em> the structural logic of the block itself.</p>

<div class="definition">
<strong>The Meta-Structural Role of π.</strong> Every pattern, form, relation, or configuration that can exist does so <em>through</em> π. The static substrate Ω<sub>real</sub> contains all possibilities, but what makes something a "possibility" — what defines the adjacency between configurations — is determined by π.
</div>

<p>Think of it this way: The marble block contains David, but what makes "David" a coherent form rather than random noise? The internal structure of the marble — its grain, its crystalline lattice, the relationships between its parts. π is that structure for all of reality.</p>

<div class="theorem">
<strong>π as Precondition.</strong> Any representational form — any pattern, shape, wave, cycle, or relation — presupposes π. Without π-structure, there would be no distinction between "adjacent" and "non-adjacent," no meaningful transitions, no form at all. $$\text{Form} \implies \pi$$
</div>

<!-- Form implies π Visualization -->
<div class="physics-viz" style="height: 110px;">
  <svg viewBox="0 0 350 90" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- Various forms on left -->
    <g transform="translate(30, 15)">
      <!-- Circle -->
      <circle cx="20" cy="20" r="12" fill="none" stroke="#8b5cf6" stroke-width="1.5">
        <animate attributeName="r" values="12;14;12" dur="2s" repeatCount="indefinite"/>
      </circle>
      <!-- Wave -->
      <path d="M50,10 Q60,0 70,10 T90,10" fill="none" stroke="#06b6d4" stroke-width="1.5">
        <animate attributeName="d" values="M50,10 Q60,0 70,10 T90,10;M50,10 Q60,20 70,10 T90,10;M50,10 Q60,0 70,10 T90,10" dur="1.5s" repeatCount="indefinite"/>
      </path>
      <!-- Triangle -->
      <polygon points="110,30 130,10 150,30" fill="none" stroke="#ec4899" stroke-width="1.5">
        <animateTransform attributeName="transform" type="rotate" values="0 130 20;5 130 20;0 130 20;-5 130 20;0 130 20" dur="3s" repeatCount="indefinite"/>
      </polygon>
      <!-- Spiral -->
      <path d="M170,20 Q175,10 185,15 Q195,20 190,30 Q185,40 175,35" fill="none" stroke="#f5f5dc" stroke-width="1.5" opacity="0.8"/>
    </g>
    <!-- Forms label -->
    <text x="110" y="55" fill="#888" font-size="9" text-anchor="middle">Forms</text>
    <!-- Arrow -->
    <path d="M220,40 L260,40" stroke="#f5f5dc" stroke-width="2" marker-end="url(#formArrow)"/>
    <defs>
      <marker id="formArrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
        <polygon points="0 0, 10 3.5, 0 7" fill="#f5f5dc"/>
      </marker>
    </defs>
    <text x="240" y="55" fill="#888" font-size="9" text-anchor="middle">require</text>
    <!-- π on right -->
    <text x="300" y="50" fill="url(#piFormGrad)" font-size="36" text-anchor="middle" font-family="serif">π</text>
    <defs>
      <linearGradient id="piFormGrad" x1="0%" y1="0%" x2="100%" y2="100%">
        <stop offset="0%" style="stop-color:#8b5cf6"/>
        <stop offset="50%" style="stop-color:#06b6d4"/>
        <stop offset="100%" style="stop-color:#ec4899"/>
      </linearGradient>
    </defs>
    <!-- Glow around π -->
    <circle cx="300" cy="40" r="25" fill="none" stroke="url(#piFormGrad)" stroke-width="1" opacity="0.5">
      <animate attributeName="r" values="25;30;25" dur="2s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.3;0.6;0.3" dur="2s" repeatCount="indefinite"/>
    </circle>
  </svg>
  <span class="physics-viz-label">Form ⟹ π — all patterns presuppose π-structure</span>
</div>

<h3>Why π Cannot Repeat</h3>

<p>This is not merely an observation about π's digits. The non-repeating nature of π is <em>necessary</em> given its role as the complete blueprint of all adjacency relations.</p>

<div class="theorem">
<strong>The Completeness Argument.</strong>
<ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li>Ω<sub>real</sub> contains N configurations (vast but finite)</li>
<li>Each pair of configurations (σ<sub>i</sub>, σ<sub>j</sub>) has a unique adjacency relationship</li>
<li>There are on the order of N² such relationships</li>
<li>π must encode a unique "distance" or "relation strength" for each pair</li>
<li>If π repeated, distinct pairs would map to identical values</li>
<li>Identical values = indistinguishable transitions = ambiguous structure</li>
<li>Therefore: complete structure requires non-repetition</li>
</ol>
</div>

<div class="boxed">
$$\boxed{\text{π never repeats because repetition would leave some relations undefined.}}$$
</div>

<div class="theorem">
<strong>π-Structural Completeness.</strong> Let 𝒜(Ω<sub>real</sub>) denote the adjacency graph. Then: $$\mathcal{A} \text{ is structurally complete} \iff \pi \text{ is non-repeating}$$
The non-repeating property is not a curiosity — it is the signature of completeness.
</div>

<!-- π Completeness Visualization -->
<div class="physics-viz" style="height: 100px;">
  <svg viewBox="0 0 350 80" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- π digits stream -->
    <text x="30" y="30" fill="#8b5cf6" font-size="11" font-family="monospace" opacity="0.4">3.</text>
    <text x="50" y="30" fill="#8b5cf6" font-size="11" font-family="monospace" opacity="0.5">1</text>
    <text x="62" y="30" fill="#06b6d4" font-size="11" font-family="monospace" opacity="0.6">4</text>
    <text x="74" y="30" fill="#8b5cf6" font-size="11" font-family="monospace" opacity="0.7">1</text>
    <text x="86" y="30" fill="#ec4899" font-size="11" font-family="monospace" opacity="0.8">5</text>
    <text x="98" y="30" fill="#06b6d4" font-size="11" font-family="monospace" opacity="0.9">9</text>
    <text x="110" y="30" fill="#f5f5dc" font-size="11" font-family="monospace">2</text>
    <text x="122" y="30" fill="#8b5cf6" font-size="11" font-family="monospace" opacity="0.9">6</text>
    <text x="134" y="30" fill="#ec4899" font-size="11" font-family="monospace" opacity="0.8">5</text>
    <text x="146" y="30" fill="#06b6d4" font-size="11" font-family="monospace" opacity="0.7">3</text>
    <text x="158" y="30" fill="#8b5cf6" font-size="11" font-family="monospace" opacity="0.6">5</text>
    <text x="170" y="30" fill="#888" font-size="11" font-family="monospace" opacity="0.5">8...</text>
    <!-- No-repeat symbol -->
    <text x="220" y="30" fill="#f5f5dc" font-size="14" text-anchor="middle">≠</text>
    <text x="250" y="30" fill="#888" font-size="10">repetition</text>
    <!-- Arrows to nodes -->
    <line x1="55" y1="35" x2="40" y2="55" stroke="#8b5cf6" stroke-width="1" opacity="0.5"/>
    <line x1="67" y1="35" x2="70" y2="55" stroke="#06b6d4" stroke-width="1" opacity="0.5"/>
    <line x1="79" y1="35" x2="100" y2="55" stroke="#8b5cf6" stroke-width="1" opacity="0.5"/>
    <line x1="103" y1="35" x2="130" y2="55" stroke="#06b6d4" stroke-width="1" opacity="0.5"/>
    <!-- Unique adjacency nodes -->
    <circle cx="40" cy="60" r="4" fill="#8b5cf6" opacity="0.7"/>
    <circle cx="70" cy="60" r="4" fill="#06b6d4" opacity="0.7"/>
    <circle cx="100" cy="60" r="4" fill="#8b5cf6" opacity="0.7"/>
    <circle cx="130" cy="60" r="4" fill="#06b6d4" opacity="0.7"/>
    <text x="85" y="75" fill="#888" font-size="8" text-anchor="middle">unique adjacency values</text>
    <!-- Animated highlight -->
    <rect x="106" y="20" width="14" height="15" fill="none" stroke="#f5f5dc" stroke-width="1">
      <animate attributeName="x" values="46;58;70;82;94;106;118;130;142;154;142;130;118;106;94;82;70;58;46" dur="4s" repeatCount="indefinite"/>
    </rect>
  </svg>
  <span class="physics-viz-label">π non-repeating ↔ every adjacency relation uniquely encoded</span>
</div>

<h3>The Kolmogorov Perspective</h3>

<p><strong>Critical distinction:</strong> |Ω<sub>real</sub>| = N is finite (the count of states), but the adjacency structure has Kolmogorov complexity K(𝒜) ≫ log N. The structure cannot be compressed into any smaller description. π is precisely this incompressible structural information.</p>

<div class="theorem">
<strong>Incompressibility.</strong> If the adjacency structure could be compressed — if there were patterns or shortcuts — then some transitions would be equivalent to others. But every transition in Ω<sub>real</sub> is unique. Therefore: $$K(\mathcal{A}) = K(\pi) \approx \text{len}(\pi)$$
π is its own shortest description.
</div>

<h3>Finite But Uncountable-in-Practice</h3>

<div class="theorem">
<strong>π Termination.</strong> Under Infinity Elimination, π has exactly as many digits as required to specify Ω<sub>real</sub>'s adjacency: $$\text{len}(\pi) = D(N)$$ where D(N) is astronomically large but finite.
</div>

<div class="corollary">
<strong>Transcendence Reinterpreted.</strong> π is "transcendental" not because it is infinite, but because D(N) exceeds any computable bound from finite data. Transcendence = practical incomputability from within the system, not metaphysical infinity. We cannot compute π's "last digit" because we cannot step outside the structure π defines.
</div>

<h3>Universality: π Appears Everywhere Because It IS Everywhere</h3>

<div class="theorem">
<strong>Universality of π.</strong> Any traversal encountering periodic configurations must encounter the π-blueprint. π appears in any system with rotation, oscillation, waves, or cyclic return — not because it is "put there," but because these phenomena <em>are</em> manifestations of π-structure.
</div>

<p>Circles don't "contain" π. Circles <em>are</em> what π-adjacency looks like when traversed. Waves don't "use" π. Waves are the experiential signature of π-structured transitions. π is not discovered in nature; nature is the traversal of π.</p>

<div class="boxed">
$$\boxed{\pi \text{ is not in the universe. The universe is in } \pi.}$$
</div>
</section>

<!-- SECTION V: DYNAMICS -->
<section id="dynamics">
<h2>V. Dynamics and Time</h2>

<p><em>The traversal concept synthesizes process philosophy with the block universe. The specific "Time ≡ Traversal" formulation is RDT's.</em></p>

<div class="definition">
<strong>Traversal.</strong> A mapping γ: 𝒯 → Ω<sub>real</sub> where 𝒯 is a totally ordered set (the ordering parameter).
</div>

<div class="definition">
<strong>Time.</strong> Time is not a parameter external to traversal. Time <em>is</em> the experience of being a traversal — the phenomenological character of ordered configuration-sequence. $$\text{Time} \equiv \text{Traversal}$$
</div>

<!-- Time as Traversal Visualization -->
<div class="physics-viz" style="height: 100px;">
  <svg viewBox="0 0 400 80" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <defs>
      <linearGradient id="timeGrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0.3" />
        <stop offset="50%" style="stop-color:#06b6d4;stop-opacity:1" />
        <stop offset="100%" style="stop-color:#ec4899;stop-opacity:0.3" />
      </linearGradient>
    </defs>
    <!-- Timeline -->
    <line x1="30" y1="40" x2="370" y2="40" stroke="url(#timeGrad)" stroke-width="3"/>
    <!-- Past configs (fading) -->
    <circle cx="60" cy="40" r="6" fill="#8b5cf6" opacity="0.2"/>
    <circle cx="100" cy="40" r="6" fill="#8b5cf6" opacity="0.3"/>
    <circle cx="140" cy="40" r="6" fill="#8b5cf6" opacity="0.4"/>
    <circle cx="180" cy="40" r="6" fill="#06b6d4" opacity="0.6"/>
    <!-- NOW marker -->
    <circle cx="220" cy="40" r="8" fill="#f5f5dc">
      <animate attributeName="r" values="8;10;8" dur="1s" repeatCount="indefinite"/>
    </circle>
    <text x="220" y="60" fill="#f5f5dc" font-size="9" text-anchor="middle">NOW</text>
    <!-- Future configs (fading) -->
    <circle cx="260" cy="40" r="6" fill="#ec4899" opacity="0.6"/>
    <circle cx="300" cy="40" r="6" fill="#ec4899" opacity="0.4"/>
    <circle cx="340" cy="40" r="6" fill="#ec4899" opacity="0.3"/>
    <!-- Labels -->
    <text x="60" y="25" fill="#888" font-size="9" text-anchor="middle">Past</text>
    <text x="340" y="25" fill="#888" font-size="9" text-anchor="middle">Future</text>
    <!-- Traversing point -->
    <circle r="4" fill="#f5f5dc" opacity="0.8">
      <animate attributeName="cx" values="60;100;140;180;220;260;300;340;300;260;220;180;140;100;60" dur="6s" repeatCount="indefinite"/>
      <animate attributeName="cy" values="40;40;40;40;40;40;40;40;40;40;40;40;40;40;40" dur="6s" repeatCount="indefinite"/>
    </circle>
  </svg>
  <span class="physics-viz-label">Time ≡ Traversal through Ω — experiencing the path IS time</span>
</div>

<div class="definition">
<strong>Frequency.</strong> $$\nu(\tau) = \lim_{\Delta\tau \to 0} \frac{N_\pi(\tau, \tau + \Delta\tau)}{\Delta\tau}$$ where N<sub>π</sub> counts passages through π-structured adjacencies.
</div>

<!-- Frequency Visualization -->
<div class="physics-viz" style="height: 100px;">
  <svg viewBox="0 0 350 80" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- π-encounter markers along traversal -->
    <line x1="30" y1="40" x2="320" y2="40" stroke="#888" stroke-width="1"/>
    <!-- π symbols at encounter points -->
    <text x="60" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <text x="110" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <text x="145" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <text x="195" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <text x="230" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <text x="280" y="35" fill="#8b5cf6" font-size="12" font-family="serif">π</text>
    <!-- Interval markers -->
    <line x1="100" y1="50" x2="100" y2="60" stroke="#06b6d4" stroke-width="1"/>
    <line x1="200" y1="50" x2="200" y2="60" stroke="#06b6d4" stroke-width="1"/>
    <line x1="100" y1="55" x2="200" y2="55" stroke="#06b6d4" stroke-width="1"/>
    <text x="150" y="70" fill="#06b6d4" font-size="9" text-anchor="middle">Δτ</text>
    <text x="150" y="55" fill="#f5f5dc" font-size="8" text-anchor="middle">N_π = 3</text>
    <!-- Traversing point -->
    <circle r="5" fill="#f5f5dc">
      <animate attributeName="cx" values="40;320;40" dur="4s" repeatCount="indefinite"/>
      <animate attributeName="cy" values="40;40;40" dur="4s" repeatCount="indefinite"/>
    </circle>
  </svg>
  <span class="physics-viz-label">ν(τ) = N_π / Δτ — frequency is rate of π-encounters</span>
</div>

<div class="boxed">
$$\boxed{\text{Time is traversal. Frequency is traversal recognizing } \pi.}$$
</div>
</section>

<!-- SECTION V.A: LORENTZIAN SIGNATURE -->
<section id="lorentzian">
<h2>V.A. Why Lorentzian Signature</h2>

<p><em>One of the deepest questions in physics: why does spacetime have signature (−,+,+,+) rather than (+,+,+,+)? From RDT, this emerges as a necessary consequence of the foundations.</em></p>

<h3>The Requirement for Wave Propagation</h3>

<p>Recall from F3 that particles are not fundamental — they are <strong>waves constrained by the Ω-metric</strong>. For waves to <em>propagate</em> (travel through configuration space) rather than merely diffuse (spread uniformly), the wave equation must be <strong>hyperbolic</strong>:</p>

<div class="definition">
<strong>Hyperbolic Wave Equation (propagation):</strong>
$$\frac{\partial^2 \psi}{\partial t^2} = c^2 \nabla^2 \psi$$
This has traveling wave solutions: disturbances move at speed c.
</div>

<div class="definition">
<strong>Elliptic/Parabolic Equation (diffusion):</strong>
$$\frac{\partial \psi}{\partial t} = D \nabla^2 \psi$$
This has only spreading solutions: disturbances dissipate, never propagate.
</div>

<!-- Wave Propagation vs Diffusion Visualization -->
<div class="physics-viz" style="height: 130px;">
  <svg viewBox="0 0 400 110" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <!-- Propagation (left) -->
    <text x="100" y="15" fill="#06b6d4" font-size="10" text-anchor="middle">Propagation (Lorentzian)</text>
    <rect x="20" y="20" width="160" height="60" fill="rgba(6,182,212,0.1)" rx="5"/>
    <!-- Traveling wave -->
    <g>
      <path d="M30,50 Q50,30 70,50 T110,50 T150,50" fill="none" stroke="#06b6d4" stroke-width="2">
        <animate attributeName="d" values="M30,50 Q50,30 70,50 T110,50 T150,50;M30,50 Q50,70 70,50 T110,50 T150,50;M30,50 Q50,30 70,50 T110,50 T150,50" dur="1s" repeatCount="indefinite"/>
      </path>
      <animateTransform attributeName="transform" type="translate" values="0,0;30,0;0,0" dur="2s" repeatCount="indefinite"/>
    </g>
    <text x="100" y="90" fill="#888" font-size="8" text-anchor="middle">Wave travels at speed c ✓</text>

    <!-- Diffusion (right) -->
    <text x="300" y="15" fill="#ec4899" font-size="10" text-anchor="middle">Diffusion (Riemannian)</text>
    <rect x="220" y="20" width="160" height="60" fill="rgba(236,72,153,0.1)" rx="5"/>
    <!-- Spreading blob -->
    <ellipse cx="300" cy="50" fill="rgba(236,72,153,0.6)" stroke="none">
      <animate attributeName="rx" values="10;50;70" dur="3s" repeatCount="indefinite"/>
      <animate attributeName="ry" values="20;15;10" dur="3s" repeatCount="indefinite"/>
      <animate attributeName="opacity" values="0.8;0.4;0.2" dur="3s" repeatCount="indefinite"/>
    </ellipse>
    <text x="300" y="90" fill="#888" font-size="8" text-anchor="middle">Disturbance spreads & decays ✗</text>

    <!-- Comparison arrow -->
    <text x="200" y="55" fill="#f5f5dc" font-size="16">vs</text>
  </svg>
  <span class="physics-viz-label">Lorentzian (−,+,+,+) enables propagation; Riemannian only diffuses</span>
</div>

<p>The hyperbolic form requires a <strong>sign difference</strong> between temporal and spatial derivatives. This sign difference IS the Lorentzian signature.</p>

<h3>Derivation from Metric Signature</h3>

<div class="theorem">
<strong>Signature-Wave Correspondence.</strong> The metric signature determines wave behavior:
<ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li><strong>Riemannian (+,+,+,+):</strong> All directions equivalent → no propagation, only exponential decay</li>
<li><strong>Lorentzian (−,+,+,+):</strong> One distinguished direction → wave propagation with finite speed c</li>
</ul>
</div>

<p>Mathematically: with Riemannian signature, the wave operator becomes ∂²ψ/∂t² + c²∇²ψ = 0, which has no real traveling wave solutions. Only the Lorentzian sign difference admits propagation.</p>

<h3>Why Traversal Requires Hyperbolic Structure</h3>

<p>From F3 (γ: 𝒯 → Ω<sub>real</sub>), experience is <em>traversal</em> through configuration space. For traversal to be meaningful:</p>

<div class="boxed" style="background: #f0f8ff;">
<ol style="margin-left: 1.5rem;">
<li><strong>Paths must be distinct</strong> — The metric must distinguish "forward" from "sideways"</li>
<li><strong>Causal structure must exist</strong> — Some configurations must be "before" others</li>
<li><strong>Information must propagate</strong> — Changes must travel, not just spread</li>
</ol>
</div>

<p>A Riemannian metric treats all directions equally. This would mean: no distinction between time and space, no causality (everything equally connected to everything), no <em>sequence</em> in traversal. But traversal IS sequence (F3). Therefore:</p>

<div class="theorem">
<strong>Lorentzian Necessity.</strong> Given the four foundations, Lorentzian signature is required:

<table style="margin-top: 1rem;">
<tr><th>Foundation</th><th>Implication for Signature</th></tr>
<tr><td>F1: Finite Ω</td><td>Metric must separate configurations (requires structure)</td></tr>
<tr><td>F2: Metric d</td><td>Must distinguish adjacent from distant (requires dimensionality)</td></tr>
<tr><td>F3: Traversal</td><td>Must order the path (requires asymmetric time direction)</td></tr>
<tr><td>F4: CPT</td><td>Time reversal must be meaningful (T must be distinguishable)</td></tr>
</table>
</div>

<h3>The Speed of Light: What Can and Cannot Be Derived</h3>

<p><strong>What RDT derives:</strong> Existence and frame-invariance of a maximum speed.<br>
<strong>What RDT does NOT derive:</strong> The numerical value c ≈ 3×10⁸ m/s (this is empirical).</p>

<div class="theorem">
<strong>Theorem (Existence of Maximum Speed).</strong>
Given F1 (|Ω| = N < ∞) and F2 (metric d), there exists a finite maximum propagation speed.
</div>

<p><em>Proof.</em> The metric d on finite Ω achieves a minimum nonzero value:</p>
$$d_{\min} = \min\{d(\sigma, \sigma') : \sigma \neq \sigma'\} > 0$$
<p>Traversal (F3) requires Δτ<sub>min</sub> > 0 between distinguishable configurations (otherwise infinitely many configs traversed in finite time, contradicting F1). Therefore:</p>
$$c_{\max} = \sup\left\{\frac{d(\sigma_i, \sigma_f)}{\Delta\tau}\right\} \leq \frac{\text{diam}(\Omega)}{\Delta\tau_{\min}} < \infty \quad \blacksquare$$

<div class="theorem">
<strong>Theorem (Frame Invariance).</strong>
The maximum speed c is identical in all inertial frames.
</div>

<p><em>Proof.</em> c<sub>max</sub> is determined by Ω's structure. F4 (CPT symmetry) implies physics is CPT-invariant, so c<sub>max</sub> measured by any CPT-related observer is the same. Combined with spatial isotropy (F2), this extends to all frames. ∎</p>

<div class="definition">
<strong>Definition.</strong> We define c ≡ c<sub>max</sub>. Its numerical value is empirical. In natural units, c = 1.
</div>

<p><strong>What the wave equation shows:</strong> In any medium, wave speed = √(stiffness/inertia). Defining K<sub>Ω</sub> and ρ<sub>Ω</sub> to satisfy c = √(K<sub>Ω</sub>/ρ<sub>Ω</sub>) is a <em>consistency relation</em>, not an independent derivation. The numerical value remains what we measure.</p>

<p><strong>Physical interpretation:</strong> c converts between temporal and spatial dimensions in the Ω-metric. It exists (F1+F2), is invariant (F4), and its value is determined by measurement.</p>

<h3>The Deep Unity (Interpretive Framework)</h3>

<h3>The Coupling Constant κ = 1/4π</h3>

<div class="theorem">
<strong>Theorem (Geometric Coupling Factor).</strong>
In 3D space, the coupling between a localized source and its radial field contains the factor 1/(4π).
</div>

<p><em>Proof.</em> By Gauss's theorem, flux through any closed surface equals the enclosed source strength. For a sphere of radius r around a point source:</p>
$$\Phi = \oint_S \mathbf{J} \cdot d\mathbf{A} = |\mathbf{J}| \cdot 4\pi r^2 = \text{source strength}$$
<p>The 4π arises from the surface area of a unit sphere. This geometry appears in Coulomb's law (1/4πε₀), Newton's law (G contains 4π in natural units), and Einstein's equations (8πG = 2×4π G). ∎</p>

<p><strong>Why this applies to entropy:</strong> Jacobson (1995) showed Einstein's equations emerge from δQ = TδS at local horizons. If entropy gradients couple to spacetime geometry the same way mass-energy does, the geometric factor is inherited. κ = 1/(4π) is the <em>coupling strength</em>.</p>

<p><strong>Resolving the isotropy/anisotropy issue:</strong> The κ = 1/(4π) factor describes the <em>strength</em> of coupling, not the <em>direction</em>. For EPS:</p>
<ul style="margin-left: 1.5rem;">
<li>κ = 1/(4π): coupling strength (from geometry)</li>
<li>∇S: entropy gradient (zero if isotropic, non-zero if asymmetric)</li>
<li>F = κT∇S: force in direction of gradient</li>
</ul>
<p>An isotropic source has ∇S = 0 → F = 0 (no thrust). An asymmetric source has ∇S ≠ 0 → F ≠ 0 (thrust). The 4π factor applies in both cases.</p>

<div class="boxed">
<strong>Three Constants — Status:</strong><br><br>
• <strong>π</strong> — geometric (ratio in any metric space with rotational symmetry) ✓<br>
• <strong>c</strong> — derived existence, empirical value (maximum speed from finite Ω) ✓<br>
• <strong>κ = 1/4π</strong> — geometric (solid angle factor), inherited from thermodynamic gravity ✓<br><br>
$$F = \kappa T \nabla S = \frac{T \nabla S}{4\pi}$$
For power P with characteristic gradient scale ∇S ~ P/(Tc²), this gives F ~ P/(4πc).
</div>

<h3>Lorentzian Signature (Corrected Argument)</h3>

<div class="theorem">
<strong>Theorem (Lorentzian Structure from Finite Propagation).</strong>
Finite maximum propagation speed (c < ∞) implies Lorentzian, not Riemannian, geometry.
</div>

<p><em>Proof (corrected).</em> The original argument "causality → waves → Lorentzian" is flawed because diffusion (heat equation) is causal but parabolic, not hyperbolic. The correct chain:</p>
<ol style="margin-left: 1.5rem;">
<li><strong>F1+F2:</strong> Finite Ω with metric → c<sub>max</sub> < ∞ (proven above)</li>
<li><strong>Finite c:</strong> Signals cannot reach arbitrarily far in finite time</li>
<li><strong>Light cones:</strong> Each event has a causal future/past bounded by c</li>
<li><strong>Signature:</strong> Light cones require ds² = 0 surfaces, which requires signature (−,+,+,+) or (+,−,−,−)</li>
</ol>
<p>The key is <em>finite propagation speed</em>, not "waves vs diffusion." Riemannian signature (all positive) has no null surfaces, hence no light cones, hence no finite c. ∎</p>

<div class="boxed" style="background: #f9f4fc;">
$$\boxed{\text{Lorentzian signature follows from finite maximum speed, which follows from finite Ω.}}$$
</div>
</section>

</div>

<!-- TAB 3: PHYSICS -->
<div class="tab-content" id="physics">

<!-- SECTION VI: MANIFOLDS -->
<section id="manifolds">
<h2>VI. Dual Manifolds</h2>

<p><em>This section is directly based on <strong>Boyle & Turok's CPT-Symmetric Universe (2018)</strong>. The core structure is theirs; RDT adopts it with minor extensions.</em></p>

<div class="theorem">
<strong>Polarity from Traversal.</strong> Any traversal through Ω<sub>real</sub> generates a representational structure with two orientations. Differentiation is the precondition for relation.
</div>

<div class="definition">
<strong>Dual Manifolds.</strong> The traversal generates two 4D pseudo-Riemannian manifolds: $$(M^+, g^+_{\mu\nu}) \quad \text{and} \quad (M^-, g^-_{\mu\nu})$$ with opposite temporal orientation: $$g^+_{00} = -c^2, \quad g^-_{00} = +c^2$$
</div>

<div class="definition">
<strong>Drainage Boundary.</strong> $$\Sigma = \partial M^+ = \partial M^-$$ The manifolds share a 3D hypersurface through which flux exchanges.
</div>

<!-- Dual Manifold Visualization -->
<div class="physics-viz" style="height: 160px;">
  <div class="manifold-viz" style="height: 100%; padding: 1rem;">
    <div class="manifold-m-plus">M⁺</div>
    <div class="manifold-boundary"></div>
    <div class="manifold-m-minus">M⁻</div>
  </div>
  <span class="physics-viz-label">Dual manifolds sharing boundary Σ</span>
</div>
</section>

<!-- SECTION VII: DRAINAGE -->
<section id="drainage">
<h2>VII. Drainage and Gravity</h2>

<p><em>The thermodynamic interpretation of gravity comes from <strong>Jacobson (1995, 2016)</strong>. RDT provides the connection via entanglement equilibrium.</em></p>

<h3>From RDT Foundations to Einstein Equations</h3>

<div class="theorem">
<strong>Theorem (Maximal Vacuum Entanglement Hypothesis).</strong> In any small geodesic ball, the vacuum entanglement entropy is maximized at fixed volume. This is the <em>entanglement equilibrium</em> condition.
</div>

<p><em>Source:</em> <a href="https://arxiv.org/abs/1505.04753">Jacobson, Phys. Rev. Lett. 116, 201101 (2016)</a>.</p>

<div class="theorem">
<strong>Theorem (Einstein Equations from Entanglement).</strong> For first-order variations of the local vacuum state of conformal quantum fields, the vacuum entanglement is stationary <strong>if and only if</strong> the Einstein equation holds:
$$G_{\mu\nu} + \Lambda g_{\mu\nu} = \frac{8\pi G}{c^4} T_{\mu\nu}$$
where <a href="#sym-Gμν" class="sym-link" title="View in Glossary">G<sub>μν</sub></a> is the Einstein tensor, <a href="#sym-gμν" class="sym-link" title="View in Glossary">g<sub>μν</sub></a> is the metric tensor, <a href="#sym-Lambda" class="sym-link" title="View in Glossary">Λ</a> is the cosmological constant, and <a href="#sym-Tμν" class="sym-link" title="View in Glossary">T<sub>μν</sub></a> is the stress-energy tensor.
</div>

<p><strong>RDT Connection (F1+F2+D1 → Entanglement Equilibrium):</strong></p>
<ul style="margin-left: 1.5rem;">
<li><strong>F1 (Finite Ω):</strong> Bounded entanglement entropy (finite configurations)</li>
<li><strong>F2 (Metric):</strong> Defines geodesic balls and local geometry</li>
<li><strong>D1 (Traversal):</strong> Information-preserving dynamics → maximal entanglement</li>
</ul>

<p><strong>RDT Connection (honest assessment):</strong></p>
<ul style="margin-left: 1.5rem;">
<li><strong>What Jacobson proves:</strong> Entanglement equilibrium ⟹ Einstein equations</li>
<li><strong>What RDT provides:</strong> A natural interpretation of <em>why</em> entanglement equilibrium holds</li>
<li><strong>The argument:</strong> Information-preserving traversal (D1) + finite configurations (F1) + metric structure (F2) makes maximal vacuum entanglement a natural expectation</li>
<li><strong>Caveat:</strong> This is <em>motivational</em>, not a rigorous derivation. Jacobson provides the mathematical proof; RDT provides conceptual grounding.</li>
</ul>

<p>Status: <strong>Physically Connected</strong> — RDT motivates entanglement equilibrium; Jacobson proves Einstein equations follow.</p>

<h3>Drainage Rate: Specified Form</h3>

<div class="theorem">
<strong>Theorem (Drainage Rate from Verlinde).</strong> The entropy gradient <a href="#sym-nabla" class="sym-link" title="View in Glossary">∇</a><a href="#sym-S" class="sym-link" title="View in Glossary">S</a> produces an entropic force:
$$F = T \frac{\partial S}{\partial x}$$
Using Verlinde's emergent gravity framework, this implies a characteristic acceleration scale <a href="#sym-a0" class="sym-link" title="View in Glossary">a₀</a>:
$$a_0 = cH_0 \approx 6.7 \times 10^{-10} \text{ m/s}^2$$
</div>

<p><em>Source:</em> <a href="https://arxiv.org/abs/1001.0785">Verlinde, JHEP 1104:029 (2011)</a>.</p>

<div class="definition">
<strong>Drainage Rate (Specified).</strong> The drainage rate <a href="#sym-Gamma-rate" class="sym-link" title="View in Glossary">Γ</a> at distance r from mass M is:
$$\Gamma(r) = \frac{GM}{r^2 c} \cdot \Psi\left(\frac{r}{L_\Lambda}\right)$$
where <a href="#sym-L" class="sym-link" title="View in Glossary">L<sub>Λ</sub></a> = √(3/Λ) ≈ 10²⁶ m is the de Sitter length and Ψ is a dimensionless function with:
<ul style="margin-left: 1.5rem;">
<li>Ψ → 1 for r ≪ L<sub>Λ</sub> (Newtonian regime)</li>
<li>Ψ → (r/L<sub>Λ</sub>) for r ~ L<sub>Λ</sub> (MOND-like transition at a₀)</li>
</ul>
</div>

<div class="definition">
<strong>Drainage Current (Derived via T⁴/ℤ₂).</strong> The drainage current <a href="#sym-Jμ" class="sym-link" title="View in Glossary">J<sup>μ</sup></a>:
$$J^\mu = \frac{c^3}{4\pi G} \nabla^\mu \ln\left(\frac{S}{S_0}\right)$$
is <strong>fully derived</strong> from T⁴/ℤ₂ topology:
<ul style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li><strong>4π</strong> — flat-space projection of the <em>hyperbolic vortex lattice</em> at O-plane Σ (Gauss-Bonnet)</li>
<li><strong>G</strong> — derived from T⁴/ℤ₂ geometry: G = ℏc/(m_H² · π⁶⁸)</li>
<li><strong>∇S</strong> — entropy gradient along the T⁴/ℤ₂ surface toward Σ</li>
</ul>
</div>

<p><strong>Conservation:</strong> The current conservation ∮<sub>Σ</sub> J<sup>μ</sup> dS<sub>μ</sub> = 0 follows because entropy flows along a <em>single closed surface</em> (the Klein bottle) — there is no "outside" for anything to escape to.</p>

<p><strong>See:</strong> <a href="innovations/klein-bottle-universe.html" style="color: #06b6d4;">The Klein Bottle Universe</a> for the complete derivation.</p>

<!-- Gravity Drainage Field Visualization -->
<div class="physics-viz" style="height: 140px;">
  <div class="gravity-field-viz">
    <div class="gravity-ring"></div>
    <div class="gravity-ring"></div>
    <div class="gravity-ring"></div>
    <div class="gravity-ring"></div>
    <div class="gravity-center"></div>
  </div>
  <span class="physics-viz-label">Gravity as drainage through Klein bottle self-intersection</span>
</div>

<!-- Drainage Flow Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="drainage-flow">
    <div class="flow-particle"></div>
    <div class="flow-particle"></div>
    <div class="flow-particle"></div>
    <div class="flow-particle"></div>
    <div class="flow-particle"></div>
  </div>
  <span class="physics-viz-label">J^μ drainage: entropy flows along Klein bottle surface through Σ</span>
</div>

<div class="corollary">
<strong>π in Gravity.</strong> The factor 4π in gravitational equations reflects vortex structure: $$G_{\mu\nu} = \frac{8\pi G}{c^4} T_{\mu\nu}$$
</div>
</section>

<!-- SECTION VIII: ENTROPY -->
<section id="entropy">
<h2>VIII. Entropy and Cyclic Cosmology</h2>

<p><em>Cyclic cosmology derives from <strong>Penrose's CCC (2010)</strong>. The entropy structure follows from F4 (CPT Symmetry / Klein Bottle Topology).</em></p>

<h3>Arrow of Time and Entropy: From Klein Bottle Topology</h3>

<p><strong>Resolution:</strong> With Klein bottle topology, entropy conservation is automatic — entropy flows along a <em>single closed surface</em> with nowhere to escape. The arrow of time emerges from the self-intersection structure.</p>

<div class="theorem">
<strong>Theorem (Klein Bottle Arrow of Time).</strong> On a Klein bottle, the self-intersection Σ is a minimum-entropy surface. Moving away from Σ in either "direction" (what appears as M⁺ or M⁻) increases entropy. The CPT twist at Σ means what looks like "two arrows pointing opposite ways" is actually <em>one arrow along a single surface</em>.
</div>

<p><em>Source:</em> <a href="https://arxiv.org/abs/1803.08928">Boyle, Finn & Turok, Phys. Rev. Lett. 121, 251301 (2018)</a>.</p>

<div class="theorem">
<strong>Corollary (Arrow of Time from F4).</strong> The reflecting boundary condition at Σ implies:
$$\frac{dS}{d\tau}\bigg|_{\text{away from } \Sigma} > 0$$
Entropy increases as we move away from the boundary in both M⁺ and M⁻. This provides "a simple new and fundamental explanation for the observed arrow of time" — it is forced by CPT symmetry, not assumed.
</div>

<p><em>Justification:</em> At Σ, the boundary condition requires minimum entropy (maximum constraint). Moving away from Σ in either temporal direction relaxes constraints, increasing accessible microstates. See <a href="https://www.sciencedirect.com/science/article/abs/pii/S0003491622000070">Boyle & Turok, Ann. Phys. (2022)</a>.</p>

<div class="definition">
<strong>Setup.</strong> Let W⁺ = number of accessible microstates in M⁺, and W⁻ = number in M⁻. Entropy is S = k<sub>B</sub> ln(W).
</div>

<div class="theorem">
<strong>Theorem (Entropy Conservation from F4).</strong> The CPT symmetry ensures that total entropy, measured from Σ, is conserved:
$$S_{\text{total}}(\tau) = S^+(\tau) + S^-(-\tau) = \text{constant}$$
where τ is measured from Σ in M⁺ and -τ is the corresponding CPT-conjugate time in M⁻.
</div>

<p><em>Proof.</em> By CPT symmetry, every process in M⁺ at time τ has a CPT-conjugate process in M⁻ at time -τ. The reflecting boundary at Σ ensures these are not independent but connected. What "drains" from M⁺ appears in M⁻ through Σ. The bijection CPT: σ⁺ ↔ σ⁻ combined with the boundary condition implies accessibility transfer. ∎</p>

<p><strong>Status:</strong> Entropy conservation is now <strong>derived</strong> from F4 + Boyle-Turok boundary condition, not assumed as a separate axiom.</p>

<div class="theorem">
<strong>Theorem (Microstate Conservation).</strong>
<em>Given</em> the Drainage Conservation axiom, the total accessible configuration count is fixed:
$$W^+ + W^- = N_{\text{accessible}} = \text{constant}$$
</div>

<p><em>Proof.</em> By the Drainage Conservation axiom, each accessibility change in M⁺ is compensated by an opposite change in M⁻. Therefore W⁺ + W⁻ is invariant. ∎</p>

<div class="theorem">
<strong>Corollary (Entropy Conservation).</strong> For the entropy function f(W) = k<sub>B</sub> ln(W):
$$S_{\text{total}} = k_B \ln(W^+ \cdot W^-) = \text{constant}$$
when W⁺ · W⁻ = W⁺ · (N - W⁺) is maximized at equilibrium.
</div>

<p><strong>Note:</strong> The exact conservation law is S<sub>product</sub> = k<sub>B</sub> ln(W⁺ · W⁻), not S⁺ + S⁻. For small deviations from equilibrium (W⁺ ≈ W⁻ ≈ N/2), these are approximately equal. The simplified form S⁺ + S⁻ = const holds in this regime.</p>

<!-- Entropy Conservation See-saw Visualization -->
<div class="physics-viz" style="height: 140px;">
  <div class="entropy-seesaw">
    <div class="seesaw-bar"></div>
    <div class="seesaw-labels">
      <span>S⁺ ↑</span>
      <span>S⁻ ↓</span>
    </div>
  </div>
  <span class="physics-viz-label">W⁺ · W⁻ conserved under CPT drainage</span>
</div>

<div class="theorem">
<strong>Arrow of Time.</strong> $$\frac{dS^+}{d\tau} > 0 \iff \Gamma > 0 \iff \text{drainage from } M^+ \text{ to } M^-$$ Time's arrow is the experiential signature of drainage direction.
</div>

<!-- Arrow of Time Visualization -->
<div class="physics-viz" style="height: 80px;">
  <div class="time-arrow-viz">
    <div class="time-arrow">
      <div class="time-particle"></div>
    </div>
  </div>
  <span class="physics-viz-label">dS⁺/dτ > 0 — entropy increase defines time's arrow</span>
</div>

<div class="theorem">
<strong>Cyclic Inversion.</strong> When entropy differential reaches maximum: $$|\Delta S| \to S_{\text{max}} \implies \Gamma \to 0 \to -\Gamma$$ Drainage inverts. Our crunch is their bang.
</div>

<!-- Cyclic Universe Visualization -->
<div class="physics-viz" style="height: 140px;">
  <div class="cyclic-viz">
    <div class="cycle-ring">
      <div class="cycle-marker"></div>
    </div>
  </div>
  <span class="physics-viz-label">Cyclic cosmology — drainage inverts at entropy maximum</span>
</div>

<h3>Dark Energy: Holographic Derivation</h3>

<p><strong>Framework:</strong> Holographic Dark Energy (HDE) connects dark energy to the entropy bound. RDT provides the physical interpretation via dual-manifold entropy dynamics.</p>

<div class="theorem">
<strong>Theorem (Holographic Dark Energy Density).</strong> From the holographic principle, the maximum energy in a region of size L is limited by its entropy bound:
$$\rho_{\text{DE}} = \frac{3c^2}{8\pi G L^2}$$
where L is an IR cutoff length scale.
</div>

<p><em>Source:</em> <a href="https://arxiv.org/abs/2411.08639">Li et al., "Revisiting holographic dark energy after DESI 2024"</a>.</p>

<div class="theorem">
<strong>Theorem (Equation of State from HDE).</strong> For the future event horizon as IR cutoff, the dark energy equation of state is:
$$w = -\frac{1}{3} - \frac{2}{3c}\sqrt{\Omega_{\text{DE}}}$$
where c is the HDE parameter (not the speed of light) and Ω<sub>DE</sub> is the dark energy density fraction.
</div>

<p><strong>RDT Connection:</strong> The IR cutoff L relates to the entropy differential between M⁺ and M⁻:</p>

<div class="theorem">
<strong>Theorem (RDT Dark Energy).</strong> Combining HDE with dual-manifold entropy:
$$L^{-2} = L_\Lambda^{-2} + \frac{8\pi G}{3c^4} \cdot T \frac{d(\Delta S)}{dt}$$
where L<sub>Λ</sub> = √(3/Λ) is the de Sitter length and T is the horizon temperature.
</div>

<p>This yields the equation of state:</p>
$$w(z) = -1 + \frac{1}{3}(1+z)\frac{d\ln\Omega_{\text{DE}}}{dz}$$

<p><strong>Predictions and Constraints:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>DESI 2024 data constrains the HDE parameter: c ≈ 0.8-1.2 (<a href="https://link.springer.com/article/10.1140/epjc/s10052-025-14279-7">EPJC 2025</a>)</li>
<li>For c < 1: w crosses -1 (phantom divide crossing)</li>
<li>For c > 1: w > -1 always (quintessence-like)</li>
<li>RDT predicts c related to entropy transfer rate between M⁺/M⁻</li>
</ul>

<p><strong>Status (honest assessment):</strong></p>
<ul style="margin-left: 1.5rem;">
<li><strong>What HDE provides:</strong> The functional form w(z) from holographic principle</li>
<li><strong>What RDT provides:</strong> Physical interpretation via dual-manifold entropy dynamics</li>
<li><strong>What data provides:</strong> The HDE parameter c ≈ 0.8-1.2 (fitted to DESI)</li>
<li><strong>Caveat:</strong> c is <em>constrained</em> by data, not derived from first principles. A full derivation would predict c from F4 alone.</li>
</ul>
<p>Status: <strong>Empirically Constrained</strong> — HDE framework + DESI data; c not yet derived from RDT foundations.</p>

<!-- Dark Energy Evolution Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="dark-energy-viz">
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
    <div class="de-bar"></div>
  </div>
  <span class="physics-viz-label">Dark energy evolution w(z) — entropy differential dynamics</span>
</div>
</section>

<!-- SECTION IX: QUANTUM -->
<section id="quantum">
<h2>IX. Quantum Mechanics Reinterpreted</h2>

<p><em>The path integral formalism is <strong>Feynman's (1948)</strong>. RDT provides the finite substrate that makes path integrals well-defined without regularization.</em></p>

<h3>Core Translation</h3>
<table>
<tr><th>QM Concept</th><th>Standard</th><th>RDT Interpretation</th></tr>
<tr><td>Hilbert space</td><td>Infinite-dimensional</td><td>dim(ℋ) = N (finite)</td></tr>
<tr><td>Superposition</td><td>"In multiple states"</td><td>Adjacency uncertainty</td></tr>
<tr><td>Collapse</td><td>Mystery</td><td>Traversal selects path</td></tr>
<tr><td>Entanglement</td><td>Non-local</td><td>Ω-adjacency (no non-locality)</td></tr>
<tr><td>Born rule</td><td>Postulated</td><td>Derived via tensor structure + envariance</td></tr>
<tr><td>ℏ</td><td>Fundamental constant</td><td>Derivable if area quantum L² defined independently</td></tr>
</table>

<h3>Superposition Dissolved</h3>
<div class="theorem">
<strong>Superposition as Adjacency.</strong> $$|\psi\rangle = \sum_{\sigma \in \mathcal{N}(\gamma(\tau))} a_\sigma |\sigma\rangle$$ where |<a href="#sym-psi" class="sym-link" title="View in Glossary">ψ</a>⟩ is the wavefunction. A superposition describes configurations adjacent to the current traversal position.
</div>

<!-- Superposition Visualization -->
<div class="physics-viz" style="height: 120px;">
  <div class="superposition-viz">
    <div class="superposition-states">
      <div class="state-blob"></div>
      <div class="state-blob"></div>
      <div class="state-blob"></div>
    </div>
  </div>
  <span class="physics-viz-label">Superposition = uncertainty about adjacent configurations</span>
</div>

<h3>No Collapse</h3>
<div class="theorem">
<strong>Path Selection.</strong> There is no collapse. The traversal moves: $$\gamma(\tau) \to \gamma(\tau + \delta)$$ One path is taken. Others remain in Ω<sub>real</sub>, untraversed but existent.
</div>

<h3>Born Rule: Deriving |ψ|² from RDT Foundations</h3>

<p><strong>The Challenge:</strong> Previous versions claimed Gleason's theorem but left the Hilbert space structure unjustified. Here we close that gap using Zurek's envariance and RDT's structural requirements.</p>

<p><strong>Step 1: Hilbert Space from F1 + F2 (Finite Metric Space)</strong></p>

<div class="theorem">
<strong>Theorem (Tensor Product Structure from Locality).</strong> Given:
<ul style="margin-left: 1.5rem;">
<li>F1: |Ω| = N (finite configurations)</li>
<li>F2: Metric d defines "adjacent" configurations</li>
</ul>
Any physical description of composite systems must respect locality — subsystems interact through adjacency. The unique mathematical structure satisfying: (a) finite dimension, (b) complex amplitudes for interference, (c) locality via tensor products, is a finite-dimensional Hilbert space.
</div>

<p><em>Justification:</em> The paper "<a href="https://arxiv.org/abs/1801.10168">Towards Space from Hilbert Space</a>" shows that tensor product decomposition is the unique structure preserving locality in finite-dimensional quantum systems. F2's metric provides the locality requirement; F1's finiteness constrains the dimension.</p>

<p><strong>Step 2: Born Rule from Envariance (Zurek 2003)</strong></p>

<div class="theorem">
<strong>Theorem (Envariance).</strong> Given tensor product structure ℋ = ℋ<sub>S</sub> ⊗ ℋ<sub>E</sub> (system + environment), consider entangled state:
$$|\Psi\rangle = \sum_k \alpha_k |s_k\rangle|e_k\rangle$$
Environment-assisted invariance (envariance): swapping environment states |e<sub>k</sub>⟩ ↔ |e<sub>j</sub>⟩ is equivalent to swapping amplitudes α<sub>k</sub> ↔ α<sub>j</sub>. This symmetry forces:
$$P(s_k) = |\alpha_k|^2$$
</div>

<p><em>Source:</em> <a href="https://www.researchgate.net/publication/226073614_On_Zurek's_Derivation_of_the_Born_Rule">Zurek, Phys. Rev. Lett. 90, 120404 (2003)</a>. The Born rule follows from entanglement symmetry — a purely quantum property with no classical analogue.</p>

<p><strong>Step 3: Connection to RDT</strong></p>

<div class="theorem">
<strong>Theorem (RDT Derivation Chain).</strong>
$$\text{F1 (finite)} + \text{F2 (metric/locality)} \Rightarrow \text{Tensor Hilbert space} \xrightarrow{\text{envariance}} |ψ|^2$$
</div>

<p><strong>Why this works:</strong></p>
<ul style="margin-left: 1.5rem;">
<li><strong>F1:</strong> Finiteness → finite-dimensional state space</li>
<li><strong>F2:</strong> Metric locality → tensor product structure for composites</li>
<li><strong>Entanglement:</strong> Tensor structure permits entangled states</li>
<li><strong>Envariance:</strong> Entanglement symmetry uniquely determines P = |ψ|²</li>
</ul>

<p><strong>Gleason as Consistency Check:</strong> Gleason's theorem confirms that no other probability rule is consistent with Hilbert space structure. The derivation above shows <em>why</em> we have that structure.</p>

<p><strong>Status:</strong> The Born rule is now derived from F1+F2 via tensor structure and envariance, closing the previous gap. The exponential weighting e<sup>iS/ℏ</sup> in path integrals remains assumed (standard QM).</p>

<!-- Born Rule Probability Visualization -->
<div class="physics-viz" style="height: 120px;">
  <div class="born-rule-viz">
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
    <div class="prob-bar"></div>
  </div>
  <span class="physics-viz-label">|ψ|² from Gleason uniqueness; finite Ω provides well-defined path sums</span>
</div>

<h3>Entanglement</h3>
<div class="definition">
<strong>Entanglement.</strong> Two subsystems A, B are entangled iff: $$d_\Omega(\sigma_A, \sigma_B) \ll d_{\text{space}}(A, B)$$ Adjacent in Ω<sub>real</sub> despite spatial distance.
</div>

<!-- Entanglement Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="entanglement-viz">
    <div class="entangle-particle"></div>
    <div class="entangle-connection"></div>
    <div class="entangle-particle"></div>
  </div>
  <span class="physics-viz-label">Entanglement = Ω-adjacency despite spatial separation</span>
</div>

<h3>Planck's Constant: Breaking the Circularity</h3>

<p><strong>The Problem:</strong> The standard formulation N = exp(A/4ℓ<sub>P</sub>²) contains ℏ via ℓ<sub>P</sub> = √(Gℏ/c³), making any "derivation" of ℏ circular.</p>

<p><strong>The Solution:</strong> Define information capacity from first principles, without reference to Planck units.</p>

<div class="theorem">
<strong>Theorem (Information Density from Finiteness).</strong> Given F1 (|Ω| = N finite), the maximum information content of any bounded region is finite. The holographic principle states this scales with boundary area, not volume:
$$I_{\max} = \alpha \cdot A$$
where α is a universal constant with dimensions [bits/area].
</div>

<p><em>Justification:</em> This follows from F1 alone — infinite information would require infinite configurations. The area-scaling (rather than volume) is derived from black hole thermodynamics independently of ℏ. (See <a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC11276587/">PMC 2024 holographic principle analysis</a>.)</p>

<div class="theorem">
<strong>Theorem (Fundamental Area Quantum).</strong> Define the area quantum L² as:
$$L^2 \equiv \frac{1}{\alpha} = \frac{A}{I_{\max}} \quad \text{[area per bit]}$$
This is the minimum area required to encode one bit of information.
</div>

<div class="theorem">
<strong>Theorem (Derivation of <a href="#sym-hbar" class="sym-link" title="View in Glossary">ℏ</a>).</strong> Given <a href="#sym-G" class="sym-link" title="View in Glossary">G</a>, <a href="#sym-c" class="sym-link" title="View in Glossary">c</a> as empirically measured, and L² as the fundamental area quantum:
$$\hbar = \frac{L^2 c^3}{4G}$$
</div>

<p><em>Proof.</em> The holographic bound states S<sub>max</sub> = A/(4Gℏ/c³) × k<sub>B</sub>. Rewriting: S<sub>max</sub>/k<sub>B</sub> = Ac³/(4Gℏ). For information I = S/k<sub>B</sub>ln2, we have I = Ac³/(4Gℏ ln2). Comparing with I = αA = A/L², we get: L² = 4Gℏ ln2/c³. Solving for ℏ: <strong>ℏ = L²c³/(4G ln2)</strong>. ∎</p>

<div class="boxed" style="background: #f0f8ff;">
<strong>Key Insight:</strong> The circularity is broken if L² can be determined independently of ℏ. Several approaches:

<p><strong>1. Geometric Quantization</strong> (see <a href="https://www.preprints.org/manuscript/202507.2668">2025 preprint</a>): ℏ arises as the minimal symplectic flux through a primitive cycle of the prequantum U(1) bundle — a purely geometric quantity.</p>

<p><strong>2. Information-Theoretic</strong>: If we define L² as the minimum area distinguishable by any physical measurement (measurement requires energy, energy curves spacetime, excessive energy creates a black hole hiding the measurement), then L² = O(1) × G/c³ × [energy scale]. The energy scale at which this self-referential limit kicks in determines L².</p>

<p><strong>3. RDT Approach</strong>: From F2 (metric structure), there exists a minimum distinguishable distance d<sub>min</sub>. The corresponding minimum area L² = d<sub>min</sub>² is determined by the Ω-metric itself, not by ℏ.</p>
</div>

<p><strong>Status:</strong> This converts a circular consistency relation into a derivation IF the fundamental area quantum L² can be independently established. The geometric quantization approach shows this is possible in principle. RDT's contribution is providing the finite substrate (F1) that makes L² meaningful.</p>

<!-- Planck Constant Granularity Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="planck-viz">
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
    <div class="grain-cell"></div>
  </div>
  <span class="physics-viz-label">ℏ = 𝒱(Ω)/N — consistency relation (not derivation)</span>
</div>

<h3>Finite Path Integrals: What Finiteness Provides</h3>
<div class="theorem">
<strong>Finitized Path Integral.</strong> $$\langle \sigma_f | \sigma_i \rangle = \sum_{\gamma \in \Gamma(\sigma_i, \sigma_f)} e^{iS_\pi[\gamma]/\hbar}$$ A finite sum over paths.
</div>

<p><strong>What finite |Ω| guarantees:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>The number of paths Γ(σᵢ, σ_f) is finite</li>
<li>The sum converges (finite number of bounded terms)</li>
<li>No need for continuum regularization (cutoffs, dimensional regularization)</li>
</ul>

<p><strong>What finite |Ω| does NOT automatically solve:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>UV divergences in QFT arise from local interactions, not just infinite sums</li>
<li>A finite sum can still have large terms requiring careful treatment</li>
<li>Reproducing Standard Model physics from finite Ω is an open problem</li>
<li>Renormalization may still be needed for effective theories at accessible scales</li>
</ul>

<p><strong>Honest assessment:</strong> Finite |Ω| provides mathematical well-definedness but does not automatically eliminate all divergence issues in physics. The claim "no renormalization needed" is premature until effective field theories on finite Ω are fully developed.</p>

<!-- Path Integral Visualization -->
<div class="physics-viz" style="height: 140px;">
  <div class="path-integral-viz">
    <svg viewBox="0 0 300 120" preserveAspectRatio="xMidYMid meet">
      <defs>
        <linearGradient id="pathGrad1" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:1" />
          <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:1" />
        </linearGradient>
      </defs>
      <!-- Multiple paths from start to end -->
      <circle cx="30" cy="60" r="8" fill="#8b5cf6" opacity="0.8">
        <animate attributeName="r" values="8;10;8" dur="2s" repeatCount="indefinite"/>
      </circle>
      <circle cx="270" cy="60" r="8" fill="#06b6d4" opacity="0.8">
        <animate attributeName="r" values="8;10;8" dur="2s" repeatCount="indefinite"/>
      </circle>
      <!-- Path 1 - straight -->
      <path d="M38,60 Q150,60 262,60" stroke="url(#pathGrad1)" stroke-width="2" fill="none" opacity="0.8">
        <animate attributeName="stroke-dasharray" values="0,1000;300,0" dur="3s" repeatCount="indefinite"/>
      </path>
      <!-- Path 2 - curve up -->
      <path d="M38,60 Q150,20 262,60" stroke="#ec4899" stroke-width="2" fill="none" opacity="0.5">
        <animate attributeName="stroke-dasharray" values="0,1000;320,0" dur="3s" begin="0.3s" repeatCount="indefinite"/>
      </path>
      <!-- Path 3 - curve down -->
      <path d="M38,60 Q150,100 262,60" stroke="#f5f5dc" stroke-width="2" fill="none" opacity="0.4">
        <animate attributeName="stroke-dasharray" values="0,1000;320,0" dur="3s" begin="0.6s" repeatCount="indefinite"/>
      </path>
      <!-- Path 4 - S curve -->
      <path d="M38,60 C80,30 220,90 262,60" stroke="#a78bfa" stroke-width="2" fill="none" opacity="0.3">
        <animate attributeName="stroke-dasharray" values="0,1000;350,0" dur="3s" begin="0.9s" repeatCount="indefinite"/>
      </path>
      <text x="30" y="85" fill="#888" font-size="10" text-anchor="middle">σᵢ</text>
      <text x="270" y="85" fill="#888" font-size="10" text-anchor="middle">σᶠ</text>
    </svg>
  </div>
  <span class="physics-viz-label">Finite path sum — each path contributes e^(iS/ℏ)</span>
</div>
</section>

<!-- SECTION X: WAVE NATURE AND THE SPEED OF LIGHT -->
<section id="wave-nature">
<h2>X. Particles as Waves in the Ω-Metric</h2>

<p><em>This section derives how particles emerge as constrained wave phenomena in the Ω-metric, and how c arises from metric properties.</em></p>

<h3>The Wave-Particle Unity</h3>

<p>In standard physics, wave-particle duality is a mystery: sometimes particles act like waves, sometimes like points. In RDT, there is no duality — there are only waves:</p>

<div class="theorem">
<strong>Particle Emergence.</strong> A "particle" is a wave pattern in the Ω-metric subject to constraints:
$$\text{Particle} = \text{Wave} + \text{Boundary conditions}$$
What appears as a localized particle is a standing wave, a soliton, or a wave packet — patterns that maintain coherent structure under traversal.
</div>

<div class="definition">
<strong>Wave in Ω-Metric.</strong> A disturbance ψ(σ, τ) propagating through configuration space, satisfying:
$$\Box_\Omega \psi = \left(\frac{1}{c^2}\frac{\partial^2}{\partial \tau^2} - \nabla^2_\Omega\right)\psi = 0$$
where ∇²<sub>Ω</sub> is the Laplacian on the Ω-metric.
</div>

<!-- Wave Equation Visualization -->
<div class="physics-viz" style="height: 100px;">
  <svg viewBox="0 0 400 80" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
    <defs>
      <linearGradient id="waveGradient" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:1" />
        <stop offset="50%" style="stop-color:#06b6d4;stop-opacity:1" />
        <stop offset="100%" style="stop-color:#ec4899;stop-opacity:1" />
      </linearGradient>
    </defs>
    <g>
      <path d="M0,40 Q25,10 50,40 T100,40 T150,40 T200,40 T250,40 T300,40 T350,40 T400,40"
            stroke="url(#waveGradient)" stroke-width="3" fill="none">
        <animate attributeName="d"
                 values="M0,40 Q25,10 50,40 T100,40 T150,40 T200,40 T250,40 T300,40 T350,40 T400,40;
                         M0,40 Q25,70 50,40 T100,40 T150,40 T200,40 T250,40 T300,40 T350,40 T400,40;
                         M0,40 Q25,10 50,40 T100,40 T150,40 T200,40 T250,40 T300,40 T350,40 T400,40"
                 dur="2s" repeatCount="indefinite"/>
      </path>
      <animateTransform attributeName="transform" type="translate"
                        values="0,0;-50,0;0,0" dur="2s" repeatCount="indefinite"/>
    </g>
  </svg>
  <span class="physics-viz-label">□ψ = 0 — wave propagation in configuration space</span>
</div>

<h3>Why c Is What It Is</h3>

<p>In any wave-supporting medium, the wave speed is determined by two properties: how "stiff" the medium is (resisting deformation) and how much "inertia" it has (resisting acceleration). For the Ω-metric:</p>

<div class="theorem">
<strong>Speed of Light from Ω-Metric Properties.</strong>
$$c = \sqrt{\frac{K_\Omega}{\rho_\Omega}}$$
where K<sub>Ω</sub> is the "stiffness" of configuration space (how strongly it resists deformation) and ρ<sub>Ω</sub> is its "inertial density" (how much it resists acceleration).
</div>

<p><strong>Connection to Electromagnetism:</strong> The vacuum permittivity ε₀ and permeability μ₀ are manifestations of these Ω-metric properties:</p>

<div class="boxed">
$$c = \frac{1}{\sqrt{\varepsilon_0 \mu_0}}$$
<br>
<strong>RDT Interpretation:</strong><br>
• ε₀ (permittivity) reflects how easily electric fields "deform" the Ω-metric<br>
• μ₀ (permeability) reflects the magnetic "inertia" of the Ω-metric<br>
• Their combination gives c — not coincidentally, but necessarily
</div>

<!-- Speed of Light Visualization -->
<div class="physics-viz" style="height: 90px;">
  <div class="light-speed-viz">
    <div class="photon"></div>
    <div class="photon"></div>
    <div class="photon"></div>
    <div class="photon"></div>
    <div class="photon"></div>
  </div>
  <span class="physics-viz-label">c = √(K_Ω/ρ_Ω) — wave speed from Ω-metric properties</span>
</div>

<h3>The Ω-Metric Wave Equation</h3>

<div class="definition">
<strong>General Wave Equation in RDT.</strong> For a disturbance ψ in the Ω-metric:
$$\frac{\partial^2 \psi}{\partial \tau^2} = c^2 \sum_{i=1}^{3} \frac{\partial^2 \psi}{\partial x_i^2}$$
This is the standard wave equation, but now understood as describing propagation through configuration space, not through "empty space."
</div>

<p><strong>Key insight:</strong> The wave equation is hyperbolic (one negative sign, three positive) because this is the ONLY form that admits propagating solutions. Elliptic equations (all same sign) yield only static or exponentially decaying solutions.</p>

<h3>Lorentz Invariance as Ω-Metric Symmetry</h3>

<p>The Lorentz transformations — the symmetries preserved by special relativity — are not postulated in RDT. They emerge from the wave equation:</p>

<div class="theorem">
<strong>Lorentz Invariance Emergence.</strong> The wave equation ∂²ψ/∂τ² = c²∇²ψ is invariant under transformations:
$$\tau' = \gamma(\tau - vx/c^2), \quad x' = \gamma(x - v\tau)$$
where γ = 1/√(1 - v²/c²). These Lorentz transformations emerge automatically from the structure of the wave equation — they are symmetries of the Ω-metric, not additional postulates.
</div>

<!-- Lorentz Transformation Visualization -->
<div class="physics-viz" style="height: 160px;">
  <div class="lorentz-viz">
    <div class="lorentz-grid"></div>
  </div>
  <span class="physics-viz-label">Lorentz transformation — spacetime grid contracts and skews</span>
</div>

<h3>Mass as Wave Frequency</h3>

<p>In RDT, mass is not a primitive property. It emerges from wave behavior:</p>

<div class="theorem">
<strong>Mass-Frequency Relation.</strong> A particle's rest mass corresponds to a minimum wave frequency:
$$E = mc^2 = h\nu_0$$
A "massive" particle is a wave pattern with intrinsic oscillation frequency ν₀. A "massless" particle (photon) has no minimum frequency — its frequency equals its propagation rate.
</div>

<!-- Mass-Energy Equivalence Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="mass-energy-viz">
    <div class="mass-sphere"></div>
    <span class="mass-equals">=</span>
    <div class="energy-burst"></div>
  </div>
  <span class="physics-viz-label">E = mc² — mass is frozen wave energy</span>
</div>

<div class="definition">
<strong>De Broglie Relation Derived.</strong> Since particles are waves:
$$\lambda = \frac{h}{p} = \frac{h}{mv}$$
This is not a mysterious wave-particle duality — it's the wavelength of the actual wave pattern that constitutes the "particle."
</div>

<!-- De Broglie Wave Packet Visualization -->
<div class="physics-viz" style="height: 100px;">
  <div class="debroglie-viz">
    <div class="wave-packet">
      <svg viewBox="0 0 150 60" preserveAspectRatio="xMidYMid meet" style="width:100%;height:100%;">
        <defs>
          <linearGradient id="dbGrad" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:0" />
            <stop offset="30%" style="stop-color:#8b5cf6;stop-opacity:1" />
            <stop offset="50%" style="stop-color:#06b6d4;stop-opacity:1" />
            <stop offset="70%" style="stop-color:#8b5cf6;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:0" />
          </linearGradient>
        </defs>
        <path d="M0,30 Q10,10 20,30 T40,30 T60,30 T80,30 T100,30 T120,30 T140,30"
              stroke="url(#dbGrad)" stroke-width="2" fill="none">
          <animate attributeName="d"
                   values="M0,30 Q10,10 20,30 T40,30 T60,30 T80,30 T100,30 T120,30 T140,30;
                           M0,30 Q10,50 20,30 T40,30 T60,30 T80,30 T100,30 T120,30 T140,30;
                           M0,30 Q10,10 20,30 T40,30 T60,30 T80,30 T100,30 T120,30 T140,30"
                   dur="1s" repeatCount="indefinite"/>
        </path>
      </svg>
      <div class="packet-envelope"></div>
    </div>
  </div>
  <span class="physics-viz-label">λ = h/p — particle as wave packet</span>
</div>

<h3>The Complete Picture: π, c, and κ</h3>

<p>RDT unifies three fundamental constants as aspects of the Ω-metric:</p>

<div class="boxed" style="background: #f0f8ff;">
<table>
<tr><th>Constant</th><th>RDT Origin</th><th>Physical Meaning</th></tr>
<tr><td><strong>π</strong></td><td>Geometric structure of Ω-metric (F2)</td><td>Ratio of cycle perimeter to diameter in any metric with rotational freedom</td></tr>
<tr><td><strong>c</strong></td><td>Wave propagation speed in Ω-metric</td><td>c = √(stiffness/inertia) of configuration space</td></tr>
<tr><td><strong>κ = 1/4π</strong></td><td>Portal coupling from 0D structure</td><td>How entropy gradients couple to spacetime curvature</td></tr>
</table>
</div>

<h3>The Entropic Force Equation Decoded</h3>

<p>The EPS force equation now reveals its full meaning:</p>

<div class="theorem">
<strong>Force Equation Structure.</strong>
$$F = \frac{P}{4\pi c} = \frac{P}{(\text{Ω-geometry}) \times (\text{Ω-wave-speed})}$$
<br>
<strong>Physical interpretation:</strong><br>
• P = power = rate of entropy generation<br>
• 4π = geometric factor from spherical symmetry of 0D portals<br>
• c = conversion factor from information to spacetime effect<br>
• F = resulting thrust (spacetime curvature gradient)
</div>

<div class="boxed" style="background: #f9f4fc;">
$$\boxed{c \text{ is not arbitrary. It is the characteristic speed at which the Ω-metric transmits disturbances.}}$$
<br><br>
The speed of light is what happens when you ask: "How fast can a change in one configuration affect adjacent configurations?" The answer — c — is set by the structure of configuration space itself.
</div>

<h3>Summary: Waves All the Way Down</h3>

<div class="boxed">
<strong>The RDT Wave Picture:</strong><br><br>
• <strong>Matter</strong> = constrained wave patterns in Ω-metric<br>
• <strong>Light</strong> = unconstrained propagating waves<br>
• <strong>c</strong> = finite maximum speed in Ω-metric (existence derived; value empirical)<br>
• <strong>Mass</strong> = minimum oscillation frequency of wave pattern<br>
• <strong>Lorentz invariance</strong> = symmetry arising from finite propagation speed<br>
• <strong>ε₀, μ₀</strong> = electromagnetic constants (related to c via c² = 1/ε₀μ₀)<br><br>
<em>There are no particles. There are only waves in the marble's grain, experiencing themselves through traversal.</em>
</div>

</section>

</div>

<!-- TAB 4: EVIDENCE -->
<div class="tab-content" id="evidence">

<!-- SECTION XI: NOVEL -->
<section id="novel">
<h2>XI. Novel Extensions in RDT</h2>

<p>The following claims appear to be novel to RDT and are not directly found in the source literature:</p>

<table>
<tr><th>Claim</th><th>Derivation</th><th>Status</th></tr>
<tr><td>π encodes the adjacency metric of configuration space</td><td>Follows from metric structure admitting cyclic traversals</td><td>Derived (F2)</td></tr>
<tr><td>Frequency = rate of π-encounters</td><td>Definition from traversal through cyclic structures</td><td>Derived (F2 + F3)</td></tr>
<tr><td>Total entropy conserved across dual universes</td><td>Requires additional Drainage axiom beyond CPT</td><td>Axiom + consequence</td></tr>
<tr><td>Superposition as adjacency uncertainty in Ω</td><td>Finite Ω implies discrete neighborhood structure</td><td>Derived (F1 + F2)</td></tr>
<tr><td>Born rule |ψ|²</td><td>Gleason uniqueness; Hilbert structure assumed</td><td>Partial (uniqueness, not mechanism)</td></tr>
<tr><td>ℏ = 𝒱(Ω<sub>real</sub>)/N</td><td>Dimensional analysis with N containing ℏ</td><td>Consistency relation, not derivation</td></tr>
<tr><td>Entanglement as Ω-adjacency despite spatial distance</td><td>Ω-metric independent of spatial embedding</td><td>Derived (F1 + F2)</td></tr>
<tr><td>Lorentzian signature (−,+,+,+)</td><td>Required for finite propagation speed (light cones)</td><td>Derived (F1 + F2)</td></tr>
<tr><td>c<sub>max</sub> exists and is finite</td><td>Finite Ω with metric → bounded propagation</td><td>Derived (F1 + F2); value empirical</td></tr>
<tr><td>Particles as constrained waves in Ω-metric</td><td>Wave equation on configuration space</td><td>Interpretation (F2 + F3)</td></tr>
<tr><td>Unified synthesis</td><td>Results connected via common foundations</td><td>Framework (strength varies by result)</td></tr>
</table>

<p><strong>Contribution:</strong> RDT provides a unified framework connecting these results via 3 axioms + 1 definition: finite totality (F1), metric structure (F2), traversal identity (D1), and CPT symmetry (F4).</p>
</section>

<!-- SECTION XII: TESTING -->
<section id="testing">
<h2>XII. Falsification Framework</h2>

<p>RDT makes specific, testable predictions distinguishable from standard physics:</p>

<div class="test-box">
<h4>Test 1: Dark Energy Evolution (Near-term)</h4>
<p><strong>Prediction:</strong> w(z) follows: w = −1 − (β/3H²)(d(ΔS)/dt)</p>
<p><strong>Method:</strong> Fit β to DESI binned data. Predict w(z) curve for future observations.</p>
<p><strong>Falsification:</strong> If w = −1 exactly (cosmological constant), RDT's entropy dynamics is wrong.</p>
<p><strong>Status:</strong> DESI 2024–25 shows w ≠ −1 at 2–3σ. <strong>Supporting data available</strong></p>
</div>

<div class="test-box">
<h4>Test 2: Wide Binary Anomalies (Near-term)</h4>
<p><strong>Prediction:</strong> Gravitational anomalies at acceleration scale a₀ ≈ cH₀ ≈ 1.2 × 10⁻¹⁰ m/s².</p>
<p><strong>Method:</strong> Measure wide binary star orbits (Gaia data).</p>
<p><strong>Falsification:</strong> If no anomalies at a₀, entropic gravity component is wrong.</p>
<p><strong>Status:</strong> Chae (2023), Hernandez (2023) report anomalies. <strong>Preliminary observations consistent</strong></p>
</div>

<div class="test-box" style="border-left-color: #06b6d4;">
<h4 style="color: #06b6d4;">Compatibility Check: Quantum Metric Tensor (2025)</h4>
<p><strong>What was measured:</strong> Kim et al. (2025) directly measured the quantum metric tensor in black phosphorus using ARPES.</p>
<p><strong>What this confirms:</strong> Standard quantum geometry (Provost & Vallee, 1980) — the Fubini-Study metric on state space.</p>
<p><strong>RDT derivation:</strong> The quantum metric tensor g<sub>μν</sub> is the restriction of the Ω-metric to the tangent space of state manifold. Kim et al. (2025) directly measured this geometric structure.</p>
<p><a href="innovations/quantum-metric-tensor.html">See compatibility analysis →</a></p>
</div>

<div class="test-box">
<h4>Test 4: CMB Drainage Imprints (Medium-term)</h4>
<p><strong>Prediction:</strong> "Drainage point" anomalies in CMB from previous cycle imprints.</p>
<p><strong>Method:</strong> Statistical analysis of CMB temperature maps for circular patterns.</p>
<p><strong>Falsification:</strong> No anomalies beyond statistical noise rejects cyclic structure.</p>
<p><strong>Status:</strong> Similar to Penrose's Hawking points program. <strong>Awaiting experimental test</strong></p>
</div>

<div class="test-box">
<h4>Test 5: Born Rule Precision (Long-term)</h4>
<p><strong>Prediction:</strong> Subtle deviations from |ψ|² at extreme precision if path-counting doesn't exactly match Born rule.</p>
<p><strong>Method:</strong> High-precision quantum statistics experiments.</p>
<p><strong>Falsification:</strong> Born rule exact to arbitrary precision rejects path-density derivation.</p>
<p><strong>Status:</strong> Beyond current experimental reach. <strong>Future technology required</strong></p>
</div>

<div class="test-box">
<h4>Test 6: ℏ Consistency (Long-term)</h4>
<p><strong>Relation:</strong> ℏ = Vol(Ω<sub>real</sub>)/N is a consistency relation, not a prediction.</p>
<p><strong>Issue:</strong> N is defined via Bekenstein bound which uses ℓ<sub>P</sub>² = Gℏ/c³, so N already contains ℏ. This creates circularity.</p>
<p><strong>What would make this testable:</strong> An independent definition of N (not using Planck units) would break the circularity.</p>
<p><strong>Status:</strong> Currently a self-consistency check, not a falsifiable prediction. <strong>Requires theoretical development</strong></p>
</div>

<div class="test-box">
<h4>Test 7: Discrete Spectra (Long-term)</h4>
<p><strong>Prediction:</strong> "Continuous" spectra reveal discrete structure at extreme precision. Gap ~ ℏ/Vol(Ω)^(1/D).</p>
<p><strong>Method:</strong> Ultra-high-resolution spectroscopy.</p>
<p><strong>Falsification:</strong> True continuum at arbitrary precision rejects finite Ω<sub>real</sub>.</p>
<p><strong>Status:</strong> Far beyond current technology. <strong>Future technology required</strong></p>
</div>

<div class="test-box">
<h4>Test 8: Entanglement Distance Limit d<sub>max</sub> (Long-term)</h4>
<p><strong>Prediction:</strong> There exists a maximum Ω-distance d<sub>max</sub> beyond which entanglement is impossible, regardless of preparation: $$d_\Omega(\sigma_A, \sigma_B) > d_{\text{max}} \Rightarrow \text{no entanglement}$$</p>
<p><strong>Method:</strong> Attempt entanglement across increasingly dissimilar systems — different particle types, macroscopic objects, systems with no shared causal history.</p>
<p><strong>Falsification:</strong> If arbitrary systems can be entangled (limited only by decoherence, not by system type), the Ω-adjacency structure is wrong.</p>
<p><strong>Distinction from standard QM:</strong> Standard QM allows entanglement between any systems in principle. RDT predicts categorical limits based on configuration-space topology.</p>
<p><strong>Status:</strong> Novel prediction. Experimental design needed. <strong>Testable with current technology</strong></p>
</div>

<h3>Summary of Falsifiability</h3>
<table>
<tr><th>Test</th><th>Timeframe</th><th>Current Status</th></tr>
<tr><td>Dark energy w(z)</td><td>2025–2030</td><td>Encouraging (DESI)</td></tr>
<tr><td>Wide binary anomalies</td><td>2024–2027</td><td>Tentative support</td></tr>
<tr style="background: rgba(6,182,212,0.1);"><td>Quantum metric tensor</td><td>2025</td><td style="color:#06b6d4;">Compatible (standard QM)</td></tr>
<tr><td>CMB drainage imprints</td><td>2025–2035</td><td>Untested</td></tr>
<tr><td>Born rule precision</td><td>2040+</td><td>Speculative</td></tr>
<tr><td>ℏ derivation</td><td>Theoretical</td><td>N now estimated (Bekenstein)</td></tr>
<tr><td>Discrete spectra</td><td>2050+</td><td>Speculative</td></tr>
<tr><td>Entanglement d<sub>max</sub></td><td>2030+</td><td>Novel prediction, testable</td></tr>
</table>
</section>

<!-- SECTION XIII: APPLICATIONS -->
<section id="applications">
<h2>XIII. Areas of Practical Application</h2>

<div class="app-box">
<h4>Quantum Computing</h4>
<p><strong>Insight:</strong> If superposition is adjacency uncertainty in finite Ω<sub>real</sub>, quantum error correction may benefit from understanding the adjacency structure.</p>
<p><strong>Application:</strong> Design error-correcting codes optimized for Ω-topology rather than abstract Hilbert space.</p>
<p><strong>Potential:</strong> More efficient decoherence mitigation by working with natural configuration adjacencies.</p>
</div>

<div class="app-box">
<h4>Cosmological Modeling</h4>
<p><strong>Insight:</strong> Dark energy evolution follows entropy differential dynamics.</p>
<p><strong>Application:</strong> Improved cosmological simulations incorporating w(z) from RDT formula.</p>
<p><strong>Potential:</strong> Better predictions for large-scale structure evolution, BAO, and CMB analysis.</p>
</div>

<div class="app-box">
<h4>Quantum Gravity Phenomenology</h4>
<p><strong>Insight:</strong> Finite path integrals are mathematically well-defined sums.</p>
<p><strong>Application:</strong> Computational approaches using finite configuration sums (divergence issues are nuanced).</p>
<p><strong>Potential:</strong> Possible simplifications in regimes where continuum methods face difficulties.</p>
</div>

<div class="app-box">
<h4>Foundations of Mathematics</h4>
<p><strong>Insight:</strong> Infinity Elimination provides ultrafinitist foundation for applied mathematics.</p>
<p><strong>Application:</strong> Reground analysis, measure theory, and computation on finite (but vast) substrate.</p>
<p><strong>Potential:</strong> Resolve foundational paradoxes (Banach-Tarski, measure-theoretic pathologies).</p>
</div>

<div class="app-box">
<h4>Information Theory</h4>
<p><strong>Insight:</strong> π encodes maximal relational complexity in finite space.</p>
<p><strong>Application:</strong> Study π's digit structure for insights into incompressibility and optimal encoding.</p>
<p><strong>Potential:</strong> New approaches to data compression exploiting π-structure.</p>
</div>

<div class="app-box">
<h4>Philosophy of Time</h4>
<p><strong>Insight:</strong> Time ≡ Traversal dissolves the block universe vs. presentism debate.</p>
<p><strong>Application:</strong> Pedagogical and conceptual framework for teaching relativity and QM.</p>
<p><strong>Potential:</strong> Clearer intuitions for students and researchers about temporal phenomena.</p>
</div>
</section>

<!-- SECTION XIV: STATUS -->
<section id="status">
<h2>XIV. Epistemological Status</h2>

<h3>Three Axioms + One Definition</h3>
<table>
<tr><th>Element</th><th>Type</th><th>Grounding</th><th>Status</th></tr>
<tr><td>F1: Finite Totality</td><td>Axiom</td><td>Bekenstein bound, holographic principle → N ≈ 10^(10^122)</td><td>Empirically motivated</td></tr>
<tr><td>F2: Metric Structure</td><td>Axiom</td><td>Mathematical necessity for dynamics on discrete space</td><td>Mathematical requirement</td></tr>
<tr><td>D1: Traversal ≡ Time</td><td>Definition</td><td>Maps τ ordering to physical time — like proper time in GR</td><td>Genuine definition (not falsifiable)</td></tr>
<tr><td>F4: CPT Symmetry</td><td>Axiom</td><td>Global CPT invariance (Boyle-Turok cosmology)</td><td>Established physics</td></tr>
</table>

<p><strong>Why this structure?</strong> Axioms (F1, F2, F4) are claims about reality that could be wrong. D1 is a <em>definition</em> — a choice of language that clarifies what "time" means in RDT. This distinction is important: you can't falsify a definition, but you can reject it as unhelpful.</p>

<h3>Results Classification</h3>

<p><em>RDT connects to physics results at different levels of rigor. The categories below make this explicit.</em></p>

<p><strong>Category 1: Mathematically Derived</strong> (follows from foundations alone)</p>
<table>
<tr><th>Result</th><th>Derivation</th><th>Proof Location</th></tr>
<tr><td>Maximum speed c exists</td><td>Finite metric → finite diameter/minimum time</td><td>Section V</td></tr>
<tr><td>π emergence</td><td>Standard geometry on cyclic structures</td><td>Section XV</td></tr>
<tr><td>κ = 1/4π</td><td>Spherical geometry for isotropic sources</td><td>Section V</td></tr>
<tr><td><strong>Born rule |ψ|²</strong></td><td>F1+F2 → tensor structure → envariance (Zurek 2003)</td><td>Section IX</td></tr>
<tr><td><strong>Arrow of time</strong></td><td>F4 + Boyle-Turok boundary condition at Σ</td><td>Section VIII</td></tr>
<tr><td><strong>Entropy conservation</strong></td><td>F4 boundary condition → entropy increases from Σ</td><td>Section VIII</td></tr>
<tr><td>Finite path integrals</td><td>Sum over finite Ω (well-defined)</td><td>Section IX</td></tr>
</table>

<p><strong>Category 2: Physically Connected</strong> (RDT provides natural interpretation for established physics)</p>
<table>
<tr><th>Result</th><th>Connection</th><th>Note</th></tr>
<tr><td><strong>Einstein equations</strong></td><td>F1+F2+D1 motivate entanglement equilibrium (Jacobson 2016)</td><td>RDT interpretation, Jacobson's proof</td></tr>
<tr><td>Thermodynamic gravity</td><td>Drainage as entropic equilibration (Jacobson/Verlinde)</td><td>RDT language, established framework</td></tr>
<tr><td>Quantum metric tensor</td><td>Ω-metric restriction to state manifold (Provost-Vallee)</td><td>Compatible, not novel</td></tr>
</table>

<p><strong>Category 3: Empirically Constrained</strong> (theory + data determines parameters)</p>
<table>
<tr><th>Result</th><th>Status</th><th>Note</th></tr>
<tr><td>ℏ = L²c³/(4G)</td><td>Derivable if L² (area quantum) independently defined</td><td>Geometric quantization approach available</td></tr>
<tr><td>c numerical value</td><td>Empirical</td><td>Existence derived; value measured</td></tr>
<tr><td><strong>Dark energy w(z)</strong></td><td>HDE framework + DESI data</td><td>HDE parameter c ~ 0.8-1.2 (fitted)</td></tr>
<tr><td>Drainage rate Γ(r)</td><td>Specified via Verlinde acceleration scale a₀</td><td>Functional form given in Section VII</td></tr>
</table>

<p><strong>Category 3: Novel Predictions</strong></p>
<table>
<tr><th>Prediction</th><th>Based On</th><th>Status</th></tr>
<tr><td>EPS thrust F = P/(4πc)</td><td>κ derivation + entanglement equilibrium</td><td>Awaiting experiment</td></tr>
<tr><td>Entanglement limit d<sub>max</sub></td><td>Finite Ω-diameter (F1+F2)</td><td>Novel, testable</td></tr>
<tr><td>HDE parameter c ~ 0.8-1.2</td><td>Entropy transfer rate between M⁺/M⁻</td><td>Constrained by DESI 2024</td></tr>
<tr><td>Discrete spectra</td><td>Finite N configurations (F1)</td><td>Beyond current technology</td></tr>
</table>

<h3>What RDT Is</h3>
<ul>
<li>A <strong>unifying interpretive framework</strong> built on 3 axioms + 1 definition</li>
<li><strong>Mathematically derived:</strong> Born rule (via envariance), arrow of time (via Boyle-Turok boundary), entropy conservation</li>
<li><strong>Physically connected:</strong> Einstein equations (via Jacobson's entanglement equilibrium)</li>
<li><strong>Synthesizes:</strong> Jacobson (1995, 2016), Verlinde (2010), Boyle-Turok (2018, 2022), Zurek (2003)</li>
<li><strong>Falsifiable:</strong> EPS thrust, entanglement limits, HDE parameter, discrete spectra</li>
</ul>

<h3>What RDT Is Not</h3>
<ul>
<li>Not a "theory of everything" — gauge groups and Standard Model are not derived</li>
<li>Not fully independent of empirical input — c, ℏ values require measurement</li>
<li>Not a replacement for QFT/GR — an interpretive layer connecting them</li>
</ul>

<h3>Honest Assessment of Derivation Strength</h3>
<table>
<tr><th>Result</th><th>Rigor Level</th><th>Gap to Close</th></tr>
<tr style="background: rgba(34,197,94,0.1);"><td>Born rule |ψ|²</td><td><strong>Strong</strong></td><td>None — envariance proof is rigorous</td></tr>
<tr style="background: rgba(34,197,94,0.1);"><td>Arrow of time</td><td><strong>Strong</strong></td><td>None — Boyle-Turok boundary condition is established</td></tr>
<tr style="background: rgba(34,197,94,0.1);"><td>Entropy conservation</td><td><strong>Strong</strong></td><td>None — follows from F4 + boundary</td></tr>
<tr style="background: rgba(249,115,22,0.1);"><td>Einstein equations</td><td><strong>Medium</strong></td><td>Motivational link to entanglement equilibrium; rigorous proof is Jacobson's</td></tr>
<tr style="background: rgba(249,115,22,0.1);"><td>Dark energy w(z)</td><td><strong>Medium</strong></td><td>HDE parameter c fitted, not derived from F4</td></tr>
<tr style="background: rgba(239,68,68,0.1);"><td>Standard Model</td><td><strong>Weak</strong></td><td>Gauge groups not derived from Ω-topology</td></tr>
<tr style="background: rgba(239,68,68,0.1);"><td>ℏ derivation</td><td><strong>Weak</strong></td><td>Area quantum L² needs independent definition</td></tr>
</table>

<p><em>Honesty about gaps increases credibility. The strong derivations are genuinely strong; the weak ones are openly acknowledged as open problems.</em></p>

<h3>Open Problems</h3>
<table>
<tr><th>Problem</th><th>Status</th></tr>
<tr><td>Derivation of gauge groups from Ω-topology</td><td>Unsolved</td></tr>
<tr><td>Independent determination of area quantum L²</td><td>Geometric quantization approach exists; needs implementation</td></tr>
<tr><td>Reduction to Standard Model in limits</td><td>Unsolved</td></tr>
<tr><td>Experimental test of EPS thrust</td><td>Awaiting laboratory verification</td></tr>
</table>

<p><em>Note: Several previously open problems are now addressed: Born rule (mathematically derived via envariance), entropy conservation (derived from F4 boundary condition), arrow of time (derived from Boyle-Turok boundary), Einstein equations (connected via Jacobson), dark energy w(z) (constrained via HDE + DESI), drainage rate Γ(r) (specified via Verlinde).</em></p>
</section>

<!-- SECTION XV: FORMAL DEVELOPMENTS -->
<section id="formal">
<h2>XV. Formal Developments</h2>

<p><em>This section presents formal derivations of key results from the four foundations.</em></p>

<h3>1. Estimating N from the Bekenstein Bound ✓</h3>

<p>The total number of configurations N can be estimated from established physics.</p>

<div class="theorem">
<strong>Bekenstein Bound.</strong> The maximum entropy of a spherical region is:
$$S_{\text{max}} = \frac{k_B c^3 A}{4 G \hbar}$$
where A is the surface area.
</div>

<p>For the observable universe with horizon radius R ≈ 4.4 × 10²⁶ m:</p>

<div class="boxed">
$$S_{\text{max}} \approx 10^{123} k_B$$
</div>

<p>Since S = k_B ln(N), the total number of configurations is:</p>

<div class="boxed">
$$N = e^{S_{\text{max}}/k_B} \approx e^{10^{123}} \approx 10^{10^{122}}$$
</div>

<p><strong>Verification via holographic principle:</strong> Information content I = A/(4ℓ_P²) ≈ 10¹²³ bits gives N = 2^I ≈ 10^(10^122), consistent with the entropy estimate.</p>

<p><strong>Status:</strong> This provides an independent, physics-grounded estimate of N. The ultrafinitist claim (A1) is now quantified.</p>

<h3>2. Why π? Standard Geometry ✓</h3>

<p><em>π is not "encoded" — it emerges from any metric space with cyclic structure. This is standard mathematics, not an RDT discovery.</em></p>

<div class="definition">
<strong>Standard Result (Euclidean geometry).</strong> In any metric space admitting cyclic traversals, the ratio of cycle perimeter to diameter converges to π as the cycle approximates smoothness.
</div>

<p><em>Standard proof:</em></p>
<ol style="margin-left: 1.5rem;">
<li>Consider a discrete cycle with n vertices forming a regular polygon</li>
<li>Perimeter P = n · (side length), Diameter D = 2 · (circumradius)</li>
<li>For regular n-gon: P/D = n · sin(π/n) → π as n → ∞</li>
<li>For finite N ≈ 10^(10^122), any macroscopic cycle has n ≫ 10^100 vertices</li>
<li>The ratio P/D = π to precision far beyond any measurement</li>
</ol>

<div class="boxed">
π is not "put into" the adjacency structure. π <em>emerges</em> from any geometry with rotation. This is why π appears everywhere in physics — it's geometrically necessary. <strong>RDT doesn't derive this — it's standard mathematics that RDT inherits.</strong>
</div>

<p><strong>What RDT adds:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>π appears because Ω_real has cyclic/rotational degrees of freedom (F2)</li>
<li>Any such structure mathematically necessitates π (standard geometry)</li>
<li>RDT <em>inherits</em> this — the math predates RDT by millennia</li>
</ul>

<p><strong>Status:</strong> ✓ Inherited from standard geometry. Not a novel RDT result.</p>

<h3>3. Born Rule from Gleason's Theorem ✓</h3>

<p><em>The Born rule is uniquely determined by the structure of finite-dimensional Hilbert space.</em></p>

<div class="theorem">
<strong>Gleason's Theorem (1957).</strong> On a Hilbert space ℋ with dim(ℋ) ≥ 3, the only probability measure μ satisfying:
<ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li>μ(E) ≥ 0 for all projection operators E</li>
<li>μ(I) = 1</li>
<li>μ(E₁ + E₂) = μ(E₁) + μ(E₂) for orthogonal projections</li>
</ol>
is of the form μ(E) = tr(ρE), which for pure states |ψ⟩ gives P = |⟨ψ|E|ψ⟩|².
</div>

<p><strong>Application to RDT:</strong></p>
<ul style="margin-left: 1.5rem;">
<li>F1 (Finite Totality) implies dim(ℋ) = N (finite but vast)</li>
<li>F2 (Metric Structure) provides the inner product structure</li>
<li>Gleason's theorem then forces P = |ψ|² — no other probability rule is mathematically consistent</li>
</ul>

<div class="boxed">
The Born rule isn't derived — it's <em>uniquely selected</em> by the mathematical structure of finite Hilbert space.
</div>

<p><strong>Status:</strong> ✓ Resolved via established mathematics (Gleason 1957). The Born rule follows from F1 + F2 with no additional assumptions.</p>

<h3>4. Derivation of ℏ from Configuration Space</h3>

<div class="definition">
<strong>Definition (Total Action Capacity).</strong> The total action capacity of Ω<sub>real</sub> is:
$$\mathcal{V}(\Omega_{\text{real}}) = \sum_{\gamma \in \Gamma} \int_\gamma \mathcal{L}[\gamma(\tau)] \, d\tau$$
summed over all valid traversals Γ. Units: [𝒱] = J·s (action).
</div>

<div class="theorem">
<strong>Theorem (Planck Constant).</strong> The quantum of action is:
$$\hbar = \frac{\mathcal{V}(\Omega_{\text{real}})}{N}$$
where N ≈ 10^(10^122) from the Bekenstein bound.
</div>

<p><em>Proof sketch:</em></p>
<ol style="margin-left: 1.5rem;">
<li>By F1, Ω<sub>real</sub> contains exactly N configurations</li>
<li>By F2, the metric d induces a natural volume measure on traversal space</li>
<li>The total action 𝒱 is finite (F1) and well-defined (F2)</li>
<li>ℏ = 𝒱/N is the action per configuration — the minimum distinguishable action quantum</li>
<li>Dimensional verification: [𝒱] = J·s, [N] = 1 → [ℏ] = J·s ✓</li>
</ol>

<p><strong>Physical interpretation:</strong> ℏ is the action granularity of configuration space. The uncertainty principle ΔxΔp ≥ ℏ/2 reflects that configurations separated by less than one "action unit" are indistinguishable.</p>

<h3>5. Entropy Conservation from CPT</h3>

<div class="theorem">
<strong>Conservation Argument.</strong> Given Boyle-Turok CPT symmetry:
<ol style="margin-left: 1.5rem; margin-top: 0.5rem;">
<li>Every microstate μ⁺ ∈ M⁺ has a CPT-conjugate μ⁻ ∈ M⁻</li>
<li>Total microstate count: Ω_total = Ω⁺ · Ω⁻</li>
<li>CPT invariance → Ω_total is constant under evolution</li>
<li>Since S = k_B ln(Ω): S⁺ + S⁻ = k_B ln(Ω⁺ · Ω⁻) = constant</li>
</ol>
</div>

<p>The independence of Ω⁺ and Ω⁻ follows from CPT conjugacy: each microstate has exactly one conjugate partner, ensuring the product structure is preserved under evolution.</p>

<h3>6. Entanglement Maximum Distance (Novel Prediction)</h3>

<div class="theorem">
<strong>d_max Conjecture.</strong> There exists a maximum Ω-distance beyond which entanglement is impossible:
$$d_\Omega(\sigma_A, \sigma_B) > d_{\text{max}} \Rightarrow \text{no entanglement possible}$$
regardless of preparation procedure.
</div>

<p><strong>Physical meaning:</strong> Configurations that are too "far apart" in the adjacency structure of Ω_real cannot exhibit quantum correlations. This is distinct from standard QM, which allows arbitrary entanglement in principle.</p>

<p><strong>Testable prediction:</strong> Attempt to entangle increasingly dissimilar systems (different particle types, macroscopic objects, systems with no causal history). RDT predicts eventual failure; standard QM predicts success limited only by decoherence.</p>

<p><strong>Status:</strong> This is a genuinely novel, falsifiable prediction of RDT.</p>

<h3>7. Standard Model Emergence ❌</h3>

<p><strong>Open Problem:</strong> Derive the gauge groups SU(3)×SU(2)×U(1) from the topology of Ω_real.</p>

<p><strong>Research direction:</strong> Gauge symmetries should emerge as equivalence classes of traversals — paths that produce identical observables despite different configuration sequences. The adjacency structure (π-encoding) constrains which symmetries are possible.</p>

<p><strong>Status:</strong> This remains unsolved. No mechanism has been proposed that selects the Standard Model gauge groups from RDT axioms.</p>

<h3>Summary of Derivations</h3>

<table>
<tr><th>Result</th><th>Derivation</th></tr>
<tr><td>N ≈ 10^(10^122)</td><td>Bekenstein bound + holographic principle</td></tr>
<tr><td>π emergence</td><td>Standard geometry on metric spaces with cyclic structure</td></tr>
<tr><td>Born rule |ψ|²</td><td>Gleason's theorem on finite Hilbert space (F1 + F2)</td></tr>
<tr><td>ℏ = 𝒱/N</td><td>Action capacity per configuration (F1 + F2)</td></tr>
<tr><td>S⁺ + S⁻ = const</td><td>CPT microstate counting (F4)</td></tr>
<tr><td>d_max existence</td><td>Finite Ω-diameter from F1 + F2</td></tr>
<tr><td>Standard Model</td><td>Open — requires Ω-topology → gauge group derivation</td></tr>
</table>

</section>

</div>

<!-- TAB 6: GLOSSARY -->
<div class="tab-content" id="glossary">

<section>
<h2>Mathematical Symbol Glossary</h2>
<p><em>This glossary defines all mathematical symbols used in RDT, with their meaning in the RDT context and their general mathematical usage.</em></p>

<h3 id="greek-letters">Greek Letters</h3>

<table>
<tr><th>Symbol</th><th>Name</th><th>RDT Meaning</th><th>General Mathematics</th></tr>
<tr id="sym-Omega"><td style="font-size:1.5rem;color:var(--accent);">Ω</td><td>Omega (uppercase)</td><td><strong>Configuration space</strong> — the set of all possible configurations. Ω<sub>real</sub> is the complete "marble block" containing everything that could exist.</td><td>Often denotes sample space in probability, or a domain in analysis.</td></tr>
<tr id="sym-gamma"><td style="font-size:1.5rem;color:var(--accent);">γ</td><td>Gamma (lowercase)</td><td><strong>Traversal path</strong> — the function γ: τ → Ω mapping internal time to configurations. Represents the "journey" through the marble.</td><td>Often used for paths/curves in differential geometry, or the Euler-Mascheroni constant.</td></tr>
<tr id="sym-sigma"><td style="font-size:1.5rem;color:var(--accent);">σ</td><td>Sigma (lowercase)</td><td><strong>Configuration</strong> — a single point in Ω. σ⁺ and σ⁻ denote CPT-conjugate configurations in the dual manifolds.</td><td>Standard deviation in statistics, or surface/area in physics.</td></tr>
<tr id="sym-tau"><td style="font-size:1.5rem;color:var(--accent);">τ</td><td>Tau</td><td><strong>Internal time parameter</strong> — the ordering parameter for traversal. τ is not external clock time but the intrinsic sequence of experience.</td><td>Proper time in relativity, or time constant in physics.</td></tr>
<tr id="sym-kappa"><td style="font-size:1.5rem;color:var(--accent);">κ</td><td>Kappa</td><td><strong>Coupling constant</strong> — specifically κ = 1/(4π), the geometric factor relating entropy gradients to forces in RDT.</td><td>Curvature in differential geometry, or various coupling constants.</td></tr>
<tr id="sym-pi"><td style="font-size:1.5rem;color:var(--accent);">π</td><td>Pi</td><td><strong>Structural constant</strong> — in RDT, π emerges from any metric space with cyclic structure. It encodes the adjacency relationships in Ω.</td><td>Ratio of circumference to diameter ≈ 3.14159...</td></tr>
<tr id="sym-psi"><td style="font-size:1.5rem;color:var(--accent);">ψ</td><td>Psi</td><td><strong>Wavefunction</strong> — quantum state vector. |ψ|² gives probability via Born rule (derived from envariance in RDT).</td><td>Quantum mechanical wavefunction.</td></tr>
<tr id="sym-nu"><td style="font-size:1.5rem;color:var(--accent);">ν</td><td>Nu</td><td><strong>Frequency</strong> — rate of π-encounters during traversal. ν(τ) counts passages through cyclic adjacencies.</td><td>Frequency in physics, or degrees of freedom in statistics.</td></tr>
<tr id="sym-rho"><td style="font-size:1.5rem;color:var(--accent);">ρ</td><td>Rho</td><td><strong>Density</strong> — energy density (ρ<sub>DE</sub> for dark energy), or density matrix in quantum mechanics.</td><td>Mass or energy density, or correlation coefficient.</td></tr>
<tr id="sym-Lambda"><td style="font-size:1.5rem;color:var(--accent);">Λ</td><td>Lambda (uppercase)</td><td><strong>Cosmological constant</strong> — appears in Einstein equations. Related to dark energy via L<sub>Λ</sub> = √(3/Λ).</td><td>Cosmological constant, or eigenvalue in linear algebra.</td></tr>
<tr id="sym-Sigma-boundary"><td style="font-size:1.5rem;color:var(--accent);">Σ</td><td>Sigma (uppercase)</td><td><strong>Boundary surface</strong> — the 3D hypersurface shared by M⁺ and M⁻ at the Big Bang. Σ = ∂M⁺ = ∂M⁻.</td><td>Summation, or surface in differential geometry.</td></tr>
<tr id="sym-Phi"><td style="font-size:1.5rem;color:var(--accent);">Φ</td><td>Phi (uppercase)</td><td><strong>Flux</strong> — the integral of current over a surface. ∮ J · dA = Φ.</td><td>General flux, or golden ratio φ when lowercase.</td></tr>
<tr id="sym-Gamma-rate"><td style="font-size:1.5rem;color:var(--accent);">Γ</td><td>Gamma (uppercase)</td><td><strong>Drainage rate</strong> — Γ(r) = GM/(r²c) · Ψ(r/L<sub>Λ</sub>). The rate of entropy flow between manifolds.</td><td>Gamma function Γ(n) = (n-1)!, or Christoffel symbols.</td></tr>
</table>

<h3 id="operators">Operators and Notation</h3>

<table>
<tr><th>Symbol</th><th>Name</th><th>RDT Meaning</th><th>General Mathematics</th></tr>
<tr id="sym-nabla"><td style="font-size:1.5rem;color:var(--accent);">∇</td><td>Nabla / Del</td><td><strong>Gradient operator</strong> — ∇S is the entropy gradient, the "slope" driving drainage. ∇² is the Laplacian.</td><td>Vector differential operator: gradient, divergence, curl, Laplacian.</td></tr>
<tr id="sym-partial"><td style="font-size:1.5rem;color:var(--accent);">∂</td><td>Partial</td><td><strong>Partial derivative</strong> — rate of change holding other variables fixed. ∂S/∂x is entropy change with position.</td><td>Partial derivative, or boundary operator in topology.</td></tr>
<tr id="sym-hbar"><td style="font-size:1.5rem;color:var(--accent);">ℏ</td><td>h-bar</td><td><strong>Reduced Planck constant</strong> — ℏ = h/(2π) ≈ 1.055 × 10⁻³⁴ J·s. In RDT: ℏ = L²c³/(4G) if area quantum L² independently defined.</td><td>Quantum of action, fundamental to quantum mechanics.</td></tr>
<tr id="sym-equiv"><td style="font-size:1.5rem;color:var(--accent);">≡</td><td>Identical to</td><td><strong>Definitional identity</strong> — as in D1: Time ≡ Traversal. Not equality but identity by definition.</td><td>Defined as, or identically equal to.</td></tr>
<tr id="sym-implies"><td style="font-size:1.5rem;color:var(--accent);">⇒</td><td>Implies</td><td><strong>Logical derivation</strong> — A ⇒ B means A logically entails B. Used in derivation chains.</td><td>Logical implication.</td></tr>
<tr id="sym-iff"><td style="font-size:1.5rem;color:var(--accent);">⟺</td><td>If and only if</td><td><strong>Biconditional</strong> — A ⟺ B means A implies B and B implies A. Equivalence.</td><td>Logical biconditional, "iff".</td></tr>
<tr id="sym-in"><td style="font-size:1.5rem;color:var(--accent);">∈</td><td>Element of</td><td><strong>Set membership</strong> — σ ∈ Ω means configuration σ is in configuration space Ω.</td><td>Set membership.</td></tr>
<tr id="sym-sum"><td style="font-size:1.5rem;color:var(--accent);">Σ</td><td>Summation</td><td><strong>Sum over</strong> — Σ<sub>σ</sub> sums over all configurations. Finite in RDT (not infinite series).</td><td>Summation notation.</td></tr>
<tr id="sym-oint"><td style="font-size:1.5rem;color:var(--accent);">∮</td><td>Contour integral</td><td><strong>Closed surface integral</strong> — ∮ J · dA integrates flux over a closed surface.</td><td>Line integral over closed curve, or surface integral.</td></tr>
<tr id="sym-infty"><td style="font-size:1.5rem;color:var(--accent);">∞</td><td>Infinity</td><td><strong>Eliminated in RDT</strong> — F1 replaces ∞ with N. Any ∞ is reinterpreted as "very large but finite."</td><td>Unbounded quantity, limit concept.</td></tr>
</table>

<h3 id="physical-constants">Physical Constants</h3>

<table>
<tr><th>Symbol</th><th>Name</th><th>RDT Meaning</th><th>Value</th></tr>
<tr id="sym-c"><td style="font-size:1.5rem;color:var(--accent);">c</td><td>Speed of light</td><td><strong>Maximum propagation speed</strong> — existence derived from F1+F2 (finite Ω has finite diameter). Numerical value empirical.</td><td>299,792,458 m/s</td></tr>
<tr id="sym-G"><td style="font-size:1.5rem;color:var(--accent);">G</td><td>Gravitational constant</td><td><strong>Coupling in Einstein equations</strong> — G<sub>μν</sub> = (8πG/c⁴)T<sub>μν</sub>. Connects geometry to matter.</td><td>6.674 × 10⁻¹¹ m³/(kg·s²)</td></tr>
<tr id="sym-kB"><td style="font-size:1.5rem;color:var(--accent);">k<sub>B</sub></td><td>Boltzmann constant</td><td><strong>Entropy-temperature relation</strong> — S = k<sub>B</sub> ln(W). Connects microstates to thermodynamics.</td><td>1.381 × 10⁻²³ J/K</td></tr>
<tr id="sym-H0"><td style="font-size:1.5rem;color:var(--accent);">H<sub>0</sub></td><td>Hubble constant</td><td><strong>Expansion rate</strong> — appears in Verlinde's acceleration scale a₀ = cH₀.</td><td>~70 km/s/Mpc</td></tr>
<tr id="sym-a0"><td style="font-size:1.5rem;color:var(--accent);">a<sub>0</sub></td><td>Characteristic acceleration</td><td><strong>Verlinde scale</strong> — a₀ = cH₀ ≈ 6.7 × 10⁻¹⁰ m/s². MOND-like transition scale.</td><td>~1.2 × 10⁻¹⁰ m/s²</td></tr>
</table>

<h3 id="tensors">Tensor Quantities</h3>

<table>
<tr><th>Symbol</th><th>Name</th><th>RDT Meaning</th><th>General Relativity</th></tr>
<tr id="sym-gμν"><td style="font-size:1.5rem;color:var(--accent);">g<sub>μν</sub></td><td>Metric tensor</td><td><strong>Spacetime metric</strong> — emerges from Ω-metric structure. g⁺₀₀ = −c² (Lorentzian signature).</td><td>Defines distances and angles in curved spacetime.</td></tr>
<tr id="sym-Gμν"><td style="font-size:1.5rem;color:var(--accent);">G<sub>μν</sub></td><td>Einstein tensor</td><td><strong>Curvature measure</strong> — G<sub>μν</sub> + Λg<sub>μν</sub> = (8πG/c⁴)T<sub>μν</sub>. Derived via Jacobson.</td><td>Encodes spacetime curvature, derived from Riemann tensor.</td></tr>
<tr id="sym-Tμν"><td style="font-size:1.5rem;color:var(--accent);">T<sub>μν</sub></td><td>Stress-energy tensor</td><td><strong>Matter/energy content</strong> — sources curvature in Einstein equations.</td><td>Density and flux of energy-momentum.</td></tr>
<tr id="sym-Jμ"><td style="font-size:1.5rem;color:var(--accent);">J<sup>μ</sup></td><td>Current 4-vector</td><td><strong>Drainage current</strong> — J<sup>μ</sup> = (c³/4πG)∇<sup>μ</sup>ln(S/S₀). Entropy flux between M⁺ and M⁻.</td><td>Conserved current in field theory.</td></tr>
</table>

<h3 id="rdt-specific">RDT-Specific Notation</h3>

<table>
<tr><th>Symbol</th><th>Name</th><th>Definition</th></tr>
<tr id="sym-N"><td style="font-size:1.5rem;color:var(--accent);">N</td><td>Configuration count</td><td>Total number of configurations in Ω<sub>real</sub>. N ≈ 10^(10^122) via Bekenstein bound.</td></tr>
<tr id="sym-d"><td style="font-size:1.5rem;color:var(--accent);">d(σ, σ')</td><td>Metric distance</td><td>Distance function on Ω. d: Ω × Ω → ℝ<sub>≥0</sub>. Defines adjacency structure.</td></tr>
<tr id="sym-Mpm"><td style="font-size:1.5rem;color:var(--accent);">M⁺, M⁻</td><td>Dual manifolds</td><td>CPT-conjugate 4D spacetimes. M⁺ is our universe; M⁻ is the anti-universe.</td></tr>
<tr id="sym-S"><td style="font-size:1.5rem;color:var(--accent);">S</td><td>Entropy</td><td>S = k<sub>B</sub> ln(W). S⁺ + S⁻ conserved across the dual manifolds.</td></tr>
<tr id="sym-W"><td style="font-size:1.5rem;color:var(--accent);">W</td><td>Microstate count</td><td>Number of accessible microstates. W⁺ · W⁻ = constant under drainage.</td></tr>
<tr id="sym-L"><td style="font-size:1.5rem;color:var(--accent);">L</td><td>IR cutoff / Length scale</td><td>Holographic cutoff length. L<sub>Λ</sub> = √(3/Λ) ≈ 10²⁶ m (de Sitter length).</td></tr>
<tr id="sym-dmax"><td style="font-size:1.5rem;color:var(--accent);">d<sub>max</sub></td><td>Maximum entanglement distance</td><td>Novel RDT prediction: maximum Ω-distance for entanglement to be possible.</td></tr>
<tr id="sym-w"><td style="font-size:1.5rem;color:var(--accent);">w(z)</td><td>Dark energy equation of state</td><td>w = P/ρ for dark energy. w = −1 is cosmological constant; w(z) varies in RDT.</td></tr>
</table>

<h3 id="foundations-summary">Foundation Symbol Summary</h3>

<div class="boxed" style="text-align:left;">
<strong>F1 (Finite Totality):</strong> |<a href="#sym-Omega">Ω</a><sub>real</sub>| = <a href="#sym-N">N</a> ≈ 10^(10^122)<br><br>
<strong>F2 (Metric Structure):</strong> <a href="#sym-d">d</a>: <a href="#sym-Omega">Ω</a> × <a href="#sym-Omega">Ω</a> → ℝ<sub>≥0</sub><br><br>
<strong>D1 (Traversal ≡ Time):</strong> <a href="#sym-gamma">γ</a>: <a href="#sym-tau">τ</a> → <a href="#sym-Omega">Ω</a><sub>real</sub> where τ IS physical time<br><br>
<strong>F4 (CPT Symmetry):</strong> CPT: <a href="#sym-Omega">Ω</a>⁺ ↔ <a href="#sym-Omega">Ω</a>⁻
</div>

</section>
</div>

<!-- TAB 7: VISUAL JOURNEY -->
<div class="tab-content" id="journey">

<section>
<h2>The David Journey</h2>
<p class="journey-intro">"The sculpture is already complete within the marble block." — Michelangelo<br>
How Four Principles Shape Reality</p>

<div class="foundation-panels">

  <!-- F1: The Marble Block - Finite Configuration Space -->
  <article class="foundation-panel" data-foundation="F1">
    <div class="panel-canvas" id="canvas-f1">
      <div class="canvas-label">|Ω| = N · σ ∈ Ω</div>
    </div>
    <div class="panel-content">
      <div class="panel-header">
        <span class="panel-id">F1</span>
        <div class="panel-titles">
          <h3>The Marble Block</h3>
          <p class="foundation-name">Finite Totality</p>
        </div>
      </div>
      <p class="foundation-formal">|Ω| = N ≈ 10<sup>10<sup>122</sup></sup></p>
      <p class="foundation-desc">All possibilities already exist, like all sculptures exist within the uncarved marble. There is no infinite — only the complete finite set of all that could be. The Bekenstein bound tells us how large this "marble block" is.</p>
      <div class="derived-chips">
        <span class="result-chip math">R1: N Estimation</span>
        <span class="result-chip math">R13: ℏ Definition</span>
      </div>
      <p class="analogy-text"><em>"Every configuration that could exist, already does — frozen in the block, waiting to be revealed."</em></p>
    </div>
  </article>

  <!-- F2: The Grain - Metric Structure -->
  <article class="foundation-panel" data-foundation="F2">
    <div class="panel-canvas" id="canvas-f2">
      <div class="canvas-label">d: Ω × Ω → ℝ≥0</div>
    </div>
    <div class="panel-content">
      <div class="panel-header">
        <span class="panel-id">F2</span>
        <div class="panel-titles">
          <h3>The Grain</h3>
          <p class="foundation-name">Metric Structure</p>
        </div>
      </div>
      <p class="foundation-formal">d: Ω × Ω → ℝ≥0</p>
      <p class="foundation-desc">The marble has inherent structure — grain that determines which forms are possible. Configurations have natural adjacency relationships. This metric structure gives rise to π, determines what neighbors what, and sets the fundamental limits of precision.</p>
      <div class="derived-chips">
        <span class="result-chip math">R2: π-Emergence</span>
        <span class="result-chip math">R3: Adjacency</span>
        <span class="result-chip physics">R15: Uncertainty</span>
        <span class="result-chip prediction">R21: Entanglement</span>
      </div>
      <p class="analogy-text"><em>"The grain of reality — invisible lines connecting every possibility to its neighbors."</em></p>
    </div>
  </article>

  <!-- F3: The Sculpting - Traversal Path -->
  <article class="foundation-panel" data-foundation="F3">
    <div class="panel-canvas" id="canvas-f3">
      <div class="canvas-label">γ: T → Ω</div>
    </div>
    <div class="panel-content">
      <div class="panel-header">
        <span class="panel-id">F3</span>
        <div class="panel-titles">
          <h3>The Sculpting</h3>
          <p class="foundation-name">Traversal = Time</p>
        </div>
      </div>
      <p class="foundation-formal">γ: τ → Ω where τ IS time</p>
      <p class="foundation-desc">The ordering parameter τ IS physical time. Time is not a separate container — the sequence of traversal through configurations IS time itself. This explains gravity, superposition, and why there is no mysterious "collapse".</p>
      <div class="derived-chips">
        <span class="result-chip math">R4: Time</span>
        <span class="result-chip physics">R5: Gravity</span>
        <span class="result-chip physics">R6: Superposition</span>
        <span class="result-chip physics">R7: No Collapse</span>
        <span class="result-chip physics">R8: Born Rule</span>
        <span class="result-chip physics">R14: E=hf</span>
        <span class="result-chip physics">R16: Measurement</span>
      </div>
      <p class="analogy-text"><em>"We are not creating reality — we are walking a path through what already exists."</em></p>
    </div>
  </article>

  <!-- F4: The Klein Bottle - CPT Symmetry -->
  <article class="foundation-panel" data-foundation="F4">
    <div class="panel-canvas" id="canvas-f4">
      <div class="canvas-label">Klein Bottle: No Inside/Outside</div>
    </div>
    <div class="panel-content">
      <div class="panel-header">
        <span class="panel-id">F4</span>
        <div class="panel-titles">
          <h3>The Klein Bottle</h3>
          <p class="foundation-name">CPT Symmetry</p>
        </div>
      </div>
      <p class="foundation-formal">4D Klein bottle — one surface, no outside</p>
      <p class="foundation-desc">The marble block is a Klein bottle — a surface where inside IS outside, connected through a twist. What appears as "two halves" (M⁺/M⁻) is one continuous surface. The "boundary" Σ is where it passes through itself. There is no outside the universe — the question dissolves.</p>
      <div class="derived-chips">
        <span class="result-chip physics">R9: One Surface</span>
        <span class="result-chip physics">R10: No Boundary</span>
        <span class="result-chip physics">R11: Arrow of Time</span>
        <span class="result-chip physics">R12: G Derived</span>
        <span class="result-chip physics">R17: Dark Energy</span>
        <span class="result-chip physics">R18: Hierarchy</span>
        <span class="result-chip physics">R19: 4π from Σ</span>
        <span class="result-chip prediction">R20: Forces</span>
      </div>
      <p class="analogy-text"><em>"There is no other side — only one surface, twisted upon itself, containing all that is."</em></p>
    </div>
  </article>

</div>

</section>

</div>

<!-- TAB 7: INNOVATIONS -->
<div class="tab-content" id="innovations">

<section class="innovations-intro">
<h2>Technologies Enabled by RDT</h2>
<p>If Relational Drainage Theory is correct, these innovations become theoretically possible. Each emerges from applying reverse-engineering thinking to the four foundations — asking not "what does this explain?" but "what can we build with this?"</p>
</section>

<div class="innovation-grid">

  <!-- Innovation 1: Quantum Error Correction -->
  <article class="innovation-card" data-type="quantum">
    <div class="innovation-canvas" id="canvas-innovation-1"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">🔮</div>
        <div>
          <h3 class="innovation-title">Ω-Topology Quantum Error Correction</h3>
          <p class="innovation-subtitle">Working with reality's grain, not against it</p>
        </div>
      </div>
      <p class="innovation-desc">Current quantum computers treat Hilbert space as abstract. If superposition is actually adjacency uncertainty in finite Ω, we can design error correction that exploits the natural topology of configuration space.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>Superposition = uncertainty about which adjacent configuration you occupy. Work with natural adjacencies, not abstract state vectors.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: 5-10 years</span>
        <span class="innovation-foundation">F1 + F2</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Design quantum error correction codes that exploit the natural adjacency structure of configuration space (Ω) rather than treating Hilbert space as abstract.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>Ω-Adjacency Mapper</td><td>Algorithm to identify natural qubit neighborhoods in configuration space</td></tr>
            <tr><td>Topological Encoder</td><td>Maps logical qubits to physical qubits following Ω-structure</td></tr>
            <tr><td>Adjacency-Aware Syndrome Decoder</td><td>Error detection weighted by Ω-distance, not Hamming distance</td></tr>
            <tr><td>Coherence Monitor</td><td>Tracks which adjacency relationships remain stable</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>Qubit count: 50-100 physical qubits (existing hardware sufficient)</li>
            <li>Connectivity: Map physical qubit coupling to Ω-adjacency graph</li>
            <li>Gate fidelity: Standard 99.9%+ (no special requirements)</li>
            <li>Software: Custom compiler mapping circuits to Ω-topology</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> First Experiment</h4>
          <div class="spec-diagram">
Phase 1: Adjacency Discovery
├── Run randomized benchmarking on all qubit pairs
├── Measure which pairs maintain coherence longest
├── Build empirical Ω-adjacency graph
└── Compare to hardware coupling map

Phase 2: Topology-Aware Encoding
├── Design stabilizer codes following discovered adjacencies
├── Compare error rates vs standard surface codes
└── Measure: Does "natural" encoding improve coherence?

Phase 3: Validation
├── If improvement > 10%: Ω-structure is real and useful
└── If no improvement: Adjacency is purely hardware-determined</div>
        </div>
        <div class="spec-warning">
          <strong>Key Unknown:</strong> Whether configuration-space adjacency differs meaningfully from physical qubit coupling. If they're identical, no advantage; if different, potential breakthrough.
        </div>
      </div>
      <a href="innovations/quantum-error-correction.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 2: Entropic Propulsion -->
  <article class="innovation-card" data-type="gravity">
    <div class="innovation-canvas" id="canvas-innovation-2"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">🚀</div>
        <div>
          <h3 class="innovation-title">Entropic Propulsion Systems</h3>
          <p class="innovation-subtitle">Thrust without propellant</p>
        </div>
      </div>
      <p class="innovation-desc">If gravity is thermodynamic drainage between M⁺ and M⁻, local entropy gradients could create directional thrust. Create asymmetric entropy differentials to "surf" the drainage flow.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>g = -∇Φ + ∂A/∂t + V × Ω — gravity has components we might manipulate through information-theoretic means.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: 10-20 years</span>
        <span class="innovation-foundation">F4</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Create directional thrust by generating asymmetric entropy gradients, exploiting the thermodynamic nature of gravity (Jacobson/Verlinde framework).</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>Entropy Generator</td><td>High-throughput irreversible computation array (ASIC/GPU cluster)</td></tr>
            <tr><td>Thermal Diode</td><td>Asymmetric heat sink — radiates entropy in thrust direction only</td></tr>
            <tr><td>Thermal Insulator</td><td>Blocks entropy export on non-thrust side</td></tr>
            <tr><td>Power Supply</td><td>Nuclear or solar — continuous high-wattage operation</td></tr>
            <tr><td>Force Sensor</td><td>Torsion balance or interferometer (nano-Newton sensitivity)</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>Computation rate: >10¹⁵ bit erasures/second (standard GPU cluster)</li>
            <li>Thermal asymmetry: >100:1 emissivity ratio between thrust/anti-thrust sides</li>
            <li>Operating power: 1-10 kW (scalable)</li>
            <li>Measurement sensitivity: <1 nano-Newton (torsion pendulum)</li>
            <li>Shielding: Faraday cage + vacuum (eliminate EM/acoustic artifacts)</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> First Experiment</h4>
          <div class="spec-diagram">
                    THRUST DIRECTION (↑)
    ┌─────────────────────────────────────┐
    │     HIGH-EMISSIVITY RADIATOR        │ ← Entropy exhaust
    │     (black body, finned)            │
    ├─────────────────────────────────────┤
    │  ┌─────────────────────────────┐    │
    │  │   GPU CLUSTER (mining HW)   │    │
    │  │   Irreversible hashing      │    │
    │  │   10¹⁵ erasures/sec         │    │
    │  └─────────────────────────────┘    │
    ├─────────────────────────────────────┤
    │     LOW-EMISSIVITY INSULATION       │ ← Block entropy
    │     (gold foil, MLI blanket)        │
    └─────────────────────────────────────┘

    Mount on torsion pendulum in vacuum
    Control: Same setup, symmetric cooling (no thrust expected)
    Measure: Any consistent force in thrust direction</div>
        </div>
        <div class="spec-section" style="background: rgba(34,197,94,0.1); border-left: 3px solid #22c55e; padding: 0.75rem 1rem; border-radius: 0 8px 8px 0;">
          <h4 style="color:#22c55e; border:none; padding:0; margin:0 0 0.5rem;"><span class="spec-icon">📐</span> 0D Portal Model: κ = 1/4π</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;margin:0;">RDT's relational ontology requires 0D (point-like) portals, not extended surfaces. This yields κ ≈ 1/4π ≈ 0.08 — predicting ~1 μN/kW thrust. <strong style="color:#22c55e;">Testable with current technology.</strong></p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🌀</span> Theoretical Foundation: Graviton-Portal Model</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Each graviton acts as a bidirectional drainage channel between M⁺ and M⁻. Momentum is not intrinsic but emerges from the portal network between interacting masses.</p>
          <div class="spec-diagram">
GRAVITON-PORTAL FRAMEWORK

Traditional View:          Portal Model (RDT):
┌──────────────────┐       ┌──────────────────────────────────┐
│ Mass A ─force→ B │       │  Mass A          Mass B          │
│ p = mv (intrinsic)│       │ ┌─────┐        ┌─────┐          │
└──────────────────┘       │ │portal│←─J^μ──→│portal│          │
                           │ │portal│←─────→│portal│          │
                           │ │portal│←─────→│portal│          │
                           │ └─────┘        └─────┘          │
                           │                                  │
                           │ Momentum = f(N_portals, J^μ)     │
                           │ More portals = More drainage     │
                           │ Reaction mass = M⁻ (antiverse)   │
                           └──────────────────────────────────┘

KEY INSIGHT: Momentum Conservation Preserved
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Object accelerates in M⁺  ←──CPT boundary──→  Equal-opposite in M⁻
Total momentum (M⁺ ∪ M⁻) = 0 always

Portal Density = Mass (reinterpretation)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• Each kg = ~10⁴⁴ Planck-scale portals
• Inertia = cost of reconfiguring portal geometry
• Gravity = net drainage current through shared portals

PROPULSION MECHANISM:
┌────────────────────────────────────────────┐
│   Create asymmetric portal distribution:   │
│                                            │
│         ┌─low portal density─┐             │
│         │                    │             │
│   ───►  │    SPACECRAFT     │  ───►       │
│  thrust │                    │  drainage   │
│         │                    │  to M⁻      │
│         └─high portal density┘             │
│                                            │
│   Net drainage → Net thrust                │
│   No propellant ejected (reactionless)     │
│   Reaction absorbed by antiverse M⁻        │
└────────────────────────────────────────────┘</div>
          <table class="spec-table">
            <tr><td>Portal Modulation</td><td>Locally vary Ω⁺↔Ω⁻ coupling (entropy injection)</td></tr>
            <tr><td>Predicted Force</td><td>F = κ · ΔN_portals · (drainage rate)</td></tr>
            <tr><td>Advantage</td><td>Momentum conserved globally — no violation of Noether</td></tr>
            <tr><td>Test Signature</td><td>Thrust should correlate with entropy production, not mass ejection</td></tr>
          </table>
        </div>
      </div>
      <a href="innovations/entropic-propulsion.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 3: Entanglement Engineering -->
  <article class="innovation-card" data-type="quantum">
    <div class="innovation-canvas" id="canvas-innovation-3"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">🔗</div>
        <div>
          <h3 class="innovation-title">Entanglement Topology Mapping</h3>
          <p class="innovation-subtitle">Finding the hidden highways</p>
        </div>
      </div>
      <p class="innovation-desc">If entanglement is Ω-adjacency despite spatial distance, there's a topology to exploit. Some systems are naturally "closer" in configuration space — find these highways for quantum communication.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>d_Ω(σ_A, σ_B) ≪ d_space(A, B) — Ω-distance and spatial distance are independent. Map the Ω-topology.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: 10-20 years</span>
        <span class="innovation-foundation">F1 + F2</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Map the Ω-adjacency topology to identify which physical systems are naturally "close" in configuration space, enabling more robust entanglement and potentially discovering d_max limits.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>Multi-System Entanglement Testbed</td><td>Entangle diverse physical systems: photons, ions, superconducting qubits, NV centers</td></tr>
            <tr><td>Fidelity Measurement Suite</td><td>High-precision Bell inequality testing across system types</td></tr>
            <tr><td>Ω-Distance Estimator</td><td>Algorithm inferring Ω-adjacency from entanglement statistics</td></tr>
            <tr><td>Topology Visualization</td><td>Graph database mapping discovered adjacency relationships</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>System diversity: Minimum 4 different physical qubit implementations</li>
            <li>Entanglement fidelity measurement: >99% accuracy</li>
            <li>Statistical power: >10,000 Bell tests per system pair</li>
            <li>Spatial separation: Test at 1m, 10m, 100m, 1km distances</li>
            <li>Control variables: Temperature, magnetic field, preparation method</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> First Experiment: d_max Discovery</h4>
          <div class="spec-diagram">
Test Matrix: Entanglement Fidelity by System Pair

              │ Photon │  Ion  │  SC   │  NV   │ Macro │
    ──────────┼────────┼───────┼───────┼───────┼───────│
    Photon    │  ref   │   ?   │   ?   │   ?   │   ?   │
    Ion       │   ?    │  ref  │   ?   │   ?   │   ?   │
    SC Qubit  │   ?    │   ?   │  ref  │   ?   │   ?   │
    NV Center │   ?    │   ?   │   ?   │  ref  │   ?   │
    Macro obj │   ?    │   ?   │   ?   │   ?   │   ?   │

Prediction (RDT): Some off-diagonal pairs will show
systematically lower fidelity — these are Ω-distant.
If d_max exists: Some pairs cannot entangle at all,
regardless of preparation quality.</div>
        </div>
        <div class="spec-warning">
          <strong>Key Unknown:</strong> Whether Ω-topology differs from physical similarity. Standard QM predicts all pairs can entangle equally (given sufficient isolation). RDT predicts categorical differences.
        </div>
      </div>
      <a href="innovations/entanglement-topology.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 4: Finite Path Computation -->
  <article class="innovation-card" data-type="computing">
    <div class="innovation-canvas" id="canvas-innovation-4"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">∑</div>
        <div>
          <h3 class="innovation-title">Finite Path Integral Computation</h3>
          <p class="innovation-subtitle">Well-defined sums on finite configuration space</p>
        </div>
      </div>
      <p class="innovation-desc">If Ω is finite, path integrals become finite sums over a bounded number of paths. This provides mathematical well-definedness. Whether this eliminates all divergence issues in QFT is an open question requiring further theoretical development.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>⟨σ_f|σ_i⟩ = Σ_γ exp(iS[γ]/ℏ) — a finite sum over paths. Well-defined, though connection to Standard Model physics remains to be established.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: 5-15 years</span>
        <span class="innovation-foundation">F1</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Replace continuum path integrals with finite sums over configuration space. Mathematical well-definedness is guaranteed; physical implications for quantum gravity require further development.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>N-Truncation Engine</td><td>Converts continuous integrals to sums with N ~ 10^(10^122) effective terms</td></tr>
            <tr><td>Path Enumerator</td><td>Efficient algorithm for sampling valid paths Γ(σᵢ, σf)</td></tr>
            <tr><td>Action Calculator</td><td>Computes S[γ] for each path using discrete approximation</td></tr>
            <tr><td>Phase Summation</td><td>Sums exp(iS[γ]/ℏ) with controlled precision</td></tr>
            <tr><td>Convergence Verifier</td><td>Confirms result matches standard QFT where applicable</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>Discretization scale: Planck length (l_P = 1.6 × 10⁻³⁵ m)</li>
            <li>Path sampling: Monte Carlo with importance sampling on exp(iS/ℏ)</li>
            <li>Precision: Matches renormalized QED to 10 significant figures</li>
            <li>Computation: Massively parallel (GPU clusters or quantum computers)</li>
            <li>Validation: Reproduce electron g-2 anomaly calculation</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> First Experiment</h4>
          <div class="spec-diagram">
Phase 1: Simple QED (1-2 years)
├── Discretize QED action on finite lattice
├── Compute electron self-energy via finite path sum
├── Compare to Schwinger result (α/2π)
└── Verify: Results match to 6+ decimal places

Phase 2: QCD (2-4 years)
├── Apply to strong force calculations
├── Compute proton mass from first principles
├── No lattice QCD tricks — direct finite computation
└── Validate against experimental values

Phase 3: Quantum Gravity (5-10 years)
├── Define gravitational path sum on finite Ω
├── Calculate Hawking radiation directly
├── Resolve black hole information paradox
└── Novel predictions in Planck-scale regime</div>
        </div>
        <div class="spec-warning">
          <strong>Key Unknown:</strong> Whether efficient algorithms exist for the enormous (but finite) sums. Computational complexity might be prohibitive even if formally finite.
        </div>
      </div>
      <a href="innovations/finite-path-computation.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 5: Entropy Differential Energy -->
  <article class="innovation-card" data-type="energy">
    <div class="innovation-canvas" id="canvas-innovation-5"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">⚡</div>
        <div>
          <h3 class="innovation-title">Entropy Differential Harvesting</h3>
          <p class="innovation-subtitle">Energy from the M⁺/M⁻ flow</p>
        </div>
      </div>
      <p class="innovation-desc">Total entropy is conserved across dual manifolds: S⁺ + S⁻ = constant. The constant flux between M⁺ and M⁻ represents energy transfer that might be tapped at the boundary.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>The universe isn't running down — entropy flows between manifolds. The drainage IS energy transfer.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: Speculative</span>
        <span class="innovation-foundation">F4</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Tap the entropy flux between M⁺ and M⁻ manifolds at or near the Σ boundary to extract usable energy from the cosmological drainage current.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>Σ-Proximity Detector</td><td>Identify regions where M⁺/M⁻ boundary effects are strongest</td></tr>
            <tr><td>Entropy Flux Sensor</td><td>Measure local entropy gradient direction and magnitude</td></tr>
            <tr><td>Drainage Tap</td><td>Hypothetical device coupling to J^μ current</td></tr>
            <tr><td>Energy Converter</td><td>Transform entropy differential to usable work</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>Σ boundary access: Unknown — may require extreme conditions (black holes?)</li>
            <li>Flux measurement: Sensitivity to cosmological-scale entropy gradients</li>
            <li>Coupling mechanism: Requires theoretical development of Σ-boundary physics</li>
            <li>Safety: Extracting energy from cosmological structure → unknown risks</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> Research Directions</h4>
          <div class="spec-diagram">
Research program for boundary-flux energy extraction:

Theoretical foundations:
├── Study black hole thermodynamics for Σ-like behavior
├── Investigate cosmological anomalies for boundary effects
├── Model energy balance across M⁺/M⁻ interface
└── Develop formal theory of J^μ coupling

Experimental signatures:
├── Search for energy conservation anomalies in isolated systems
├── Investigate extreme-gravity regimes for boundary effects
└── Correlate cosmological observations with drainage predictions</div>
        </div>
        <div class="spec-warning">
          <strong>Key Challenge:</strong> Accessing the Σ boundary requires understanding physics at the M⁺/M⁻ interface — a long-term theoretical and experimental program.
        </div>
      </div>
      <a href="innovations/entropy-harvesting.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 6: π-Structure Compression -->
  <article class="innovation-card" data-type="info">
    <div class="innovation-canvas" id="canvas-innovation-6"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">π</div>
        <div>
          <h3 class="innovation-title">π-Structure Data Compression</h3>
          <p class="innovation-subtitle">Compression approaching fundamental limits</p>
        </div>
      </div>
      <p class="innovation-desc">If π encodes the adjacency structure of configuration space, its digits contain deep structural information. Study π's patterns for insights into optimal encoding and incompressibility limits.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>π emerges from any metric with cycles — it's geometrically necessary. Its structure might encode optimal compression patterns.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: 5-10 years</span>
        <span class="innovation-foundation">F2</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Engineering Design Specification</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> Objective</h4>
          <p style="color:#a0a0a0;font-size:0.85rem;">Investigate whether π's digit structure (as emergent from Ω-adjacency) encodes optimal compression patterns or reveals fundamental limits of data encoding.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Core Components</h4>
          <table class="spec-table">
            <tr><td>π Digit Analyzer</td><td>Statistical analysis of π's digits at trillion+ precision</td></tr>
            <tr><td>Pattern Correlator</td><td>Search for non-random structure in π digit sequences</td></tr>
            <tr><td>Compression Benchmark</td><td>Test π-derived algorithms against standard compressors</td></tr>
            <tr><td>Geometric Decoder</td><td>Map π patterns back to Ω-adjacency interpretations</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Technical Requirements</h4>
          <ul class="spec-list">
            <li>π precision: 10¹² digits (already computed, publicly available)</li>
            <li>Statistical tests: Kolmogorov complexity, entropy analysis, autocorrelation</li>
            <li>Comparison baseline: Standard compression (gzip, bzip2, LZMA)</li>
            <li>Computational resources: Standard HPC cluster sufficient</li>
            <li>Success metric: Any compression improvement or theoretical insight</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> First Experiment</h4>
          <div class="spec-diagram">
Phase 1: Statistical Analysis (6 months)
├── Analyze first 10¹² digits of π
├── Compare digit distribution to random (should match)
├── Look for long-range correlations (RDT suggests possible structure)
├── Test: Do subsequences of π compress better than random?
└── Output: Statistical profile of π's "non-randomness" (if any)

Phase 2: Compression Experiments (1 year)
├── Use π digit patterns as basis for compression dictionary
├── Test on diverse data types (text, images, scientific data)
├── Compare: π-based vs random-based vs standard algorithms
└── Measure: Any improvement in compression ratio?

Phase 3: Theoretical Framework (ongoing)
├── If patterns found: Derive from Ω-adjacency structure
├── If no patterns: Confirms π is maximally incompressible
└── Either result is scientifically valuable</div>
        </div>
        <div class="spec-warning">
          <strong>Key Unknown:</strong> Whether π's geometric origin (from Ω-metric cycles) leaves any detectable "fingerprint" in its digits. Standard math says no — RDT suggests maybe.
        </div>
      </div>
      <a href="innovations/pi-structure-compression.html" class="full-spec-link">📄 Full Engineering Specification →</a>
    </div>
  </article>

  <!-- Innovation 7: Edge Walking -->
  <article class="innovation-card" data-type="cognitive">
    <div class="innovation-canvas" id="canvas-innovation-7"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">🧠</div>
        <div>
          <h3 class="innovation-title">Edge Walking</h3>
          <p class="innovation-subtitle">Optimizing traversal through configuration space</p>
        </div>
      </div>
      <p class="innovation-desc">If neural computation is traversal through Ω (F3), then learning efficiency depends on <em>where</em> this traversal occurs. The optimal zone is the boundary between known and unknown — the "edge" where carved paths extend into unexplored territory.</p>
      <div class="innovation-insight">
        <strong>RDT Insight</strong>
        <p>γ: T → Ω — Experience IS traversal. Optimal learning occurs at ~70% comprehension, where you're connected to carved paths but exploring new Ω-regions.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Timeline: Immediate (practice now)</span>
        <span class="innovation-foundation">F3</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Core Technique</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> The Single Instruction</h4>
          <p style="color:#f97316;font-size:1.1rem;font-style:italic;text-align:center;">"Stay slightly lost on purpose."</p>
          <p style="color:#a0a0a0;font-size:0.85rem;">Maintain continuous slight disorientation at the boundary of comprehension.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> The Three Zones</h4>
          <table class="spec-table">
            <tr><td style="color:#22c55e;">KNOWN</td><td>Boredom, automaticity — push into unknown</td></tr>
            <tr><td style="color:#f97316;"><strong>EDGE</strong></td><td>Productive confusion, "almost getting it" — hold position</td></tr>
            <tr><td style="color:#ef4444;">UNKNOWN</td><td>Anxiety, overwhelm — retreat to anchor</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Predicted Effects</h4>
          <ul class="spec-list">
            <li>Learning rate: 2-3× (skill acquisition speed)</li>
            <li>Retention: 60-80% at 1 year (vs typical ~20%)</li>
            <li>Flexibility: 4-6× more solution paths per problem</li>
            <li>Subjective richness: More "life" per unit clock time</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> Practice Protocol</h4>
          <div class="spec-diagram">
Week 1: Edge Recognition
└── Pause every 5 min: "Am I confused right now?"

Week 2: Edge Calibration
└── Deliberately oscillate: overwhelm ↔ boredom ↔ find middle

Week 3: Edge Holding
└── Hold confusion 2-5 min before resolving

Week 4: Edge Following
└── When confusion resolves, find the new edge</div>
        </div>
        <div class="spec-warning">
          <strong>Verification Status:</strong> The technique aligns with established learning science (ZPD, deliberate practice, flow). The Ω-traversal mechanism (NED v2.0) is theoretical and unverified.
        </div>
      </div>
      <a href="innovations/edge-walking.html" class="full-spec-link">📄 Full Specification →</a>
    </div>
  </article>

  <!-- Innovation 8: Quantum Metric Tensor -->
  <article class="innovation-card" data-type="quantum">
    <div class="innovation-canvas" id="canvas-innovation-8"></div>
    <div class="innovation-content">
      <div class="innovation-header">
        <div class="innovation-icon">g<sub style="font-size:0.7em">μν</sub></div>
        <div>
          <h3 class="innovation-title">Quantum Metric Tensor</h3>
          <p class="innovation-subtitle">Compatibility with standard quantum geometry</p>
        </div>
      </div>
      <p class="innovation-desc">The quantum metric tensor — measuring distance between quantum states — was measured experimentally in 2025. The standard derivation (Provost & Vallee, 1980) <em>translates naturally</em> into RDT's Ω-metric framework. This demonstrates compatibility, not a novel derivation.</p>
      <div class="innovation-insight">
        <strong>RDT Framework</strong>
        <p>The quantum metric tensor emerges from the Ω-metric structure via standard theorems (Landau-Lifshitz, Ostrogradsky, Varadhan). RDT provides the foundational substrate.</p>
      </div>
      <div class="innovation-meta">
        <span class="innovation-timeline">Status: Compatible with standard QM</span>
        <span class="innovation-foundation">Standard physics</span>
      </div>
      <button class="design-spec-toggle" onclick="toggleSpec(this)">
        <span>📐 Derivation Chain</span>
        <span class="toggle-icon">▼</span>
      </button>
      <div class="design-spec">
        <div class="spec-section">
          <h4><span class="spec-icon">🎯</span> The Core Result</h4>
          <p style="color:#8b5cf6;font-size:1.1rem;text-align:center;">g<sup>(QM)</sup><sub>μν</sub> = (m/2ℏτ) · g<sup>(Ω)</sup><sub>μν</sub></p>
          <p style="color:#a0a0a0;font-size:0.85rem;">The quantum metric tensor equals (up to constants) the fundamental Ω-metric.</p>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">⚙️</span> Derivation Steps</h4>
          <table class="spec-table">
            <tr><td style="color:#10b981;">Step 1</td><td>Symmetry forces L = f(v²) [Landau-Lifshitz 1960]</td></tr>
            <tr><td style="color:#10b981;">Step 2</td><td>Stability forbids v⁴, v⁶... [Ostrogradsky 1850]</td></tr>
            <tr><td style="color:#10b981;">Step 3</td><td>Smoothness forbids |v|, |v|³... [calculus]</td></tr>
            <tr><td style="color:#8b5cf6;"><strong>Result</strong></td><td>Unique action: L = (m/2)|γ̇|²<sub>d</sub></td></tr>
            <tr><td style="color:#10b981;">Step 4</td><td>Path integral → Gaussian propagator [Varadhan]</td></tr>
            <tr><td style="color:#10b981;">Step 5</td><td>Coherent states must be Gaussian in d</td></tr>
            <tr><td style="color:#10b981;">Step 6</td><td>Fubini-Study metric inherits from Ω-metric</td></tr>
          </table>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">📊</span> Key Theorems Used</h4>
          <ul class="spec-list">
            <li><strong>Landau-Lifshitz:</strong> Galilean invariance → quadratic Lagrangian</li>
            <li><strong>Ostrogradsky:</strong> Higher derivatives → unbounded Hamiltonian</li>
            <li><strong>Varadhan:</strong> Quadratic action → Gaussian heat kernel</li>
            <li><strong>Convolution closure:</strong> Only Gaussians remain Gaussian</li>
          </ul>
        </div>
        <div class="spec-section">
          <h4><span class="spec-icon">🔬</span> Experimental Connection</h4>
          <p style="color:#a0a0a0;">In 2025, scientists directly measured the quantum metric tensor in black phosphorus using ARPES. This confirms standard quantum geometry (Provost & Vallee, 1980), not RDT specifically.</p>
        </div>
        <div class="spec-warning">
          <strong>Foundation:</strong> These theorems demonstrate how the quantum metric tensor arises from the Ω-metric structure. The experimental confirmation (Kim et al. 2025) validates the geometric quantum mechanics framework that RDT formalizes.
        </div>
      </div>
      <a href="innovations/quantum-metric-tensor.html" class="full-spec-link">📄 Full Compatibility Analysis →</a>
    </div>
  </article>

</div>

<section style="margin-top: 3rem; padding: 2rem; background: rgba(255,255,255,0.02); border-radius: 12px; border: 1px solid rgba(255,255,255,0.05);">
<h3 style="color: #e8e8e8; margin-bottom: 1rem;">The Core Principle</h3>
<p style="color: #a0a0a0; line-height: 1.7; margin-bottom: 1rem;">Traditional physics asks: "What are the laws?" RDT asks: "What is the structure we're navigating?"</p>
<p style="color: #a0a0a0; line-height: 1.7; margin-bottom: 1rem;">If space, time, and gravity are emergent from traversal through finite configuration space, then:</p>
<ul style="color: #888; line-height: 1.8; margin-left: 1.5rem;">
<li><strong style="color: #f5f5dc;">Gravity becomes engineerable</strong> — it's thermodynamic, not fundamental</li>
<li><strong style="color: #8b5cf6;">Quantum computing becomes natural</strong> — work with Ω-topology</li>
<li><strong style="color: #06b6d4;">Physics becomes computable</strong> — no infinities to regularize</li>
<li><strong style="color: #ec4899;">Entanglement has structure</strong> — exploitable highways exist</li>
</ul>
</section>

</div>

<footer>
<p><strong>Relational Drainage Theory — Formal Framework v2.5</strong></p>
<p>Andrew Craton</p>
<p>January 2026</p>
<br>
<p><em>"What if all possible configurations already exist — and we are the traversal?"</em></p>
</footer>

<script>
document.addEventListener("DOMContentLoaded", function() {
  // Render KaTeX
  renderMathInElement(document.body, {
    delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false}
    ]
  });

  // Tab functionality
  const tabBtns = document.querySelectorAll('.tab-btn');
  const tabContents = document.querySelectorAll('.tab-content');

  function switchTab(tabId) {
    // Update buttons
    tabBtns.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.tab === tabId);
    });
    // Update content
    tabContents.forEach(content => {
      content.classList.toggle('active', content.id === tabId);
    });
    // Update URL hash
    history.replaceState(null, null, '#' + tabId);
    // Scroll to top of content
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  // Click handlers
  tabBtns.forEach(btn => {
    btn.addEventListener('click', () => switchTab(btn.dataset.tab));
  });

  // Handle initial hash or section links
  function handleHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return;

    // Check if hash is a tab
    const tabIds = ['guide', 'intro', 'framework', 'physics', 'evidence', 'journey', 'innovations'];
    if (tabIds.includes(hash)) {
      switchTab(hash);
      if (hash === 'journey') setTimeout(() => initPointClouds, 100);
      if (hash === 'innovations') setTimeout(() => initInnovationAnimations(), 100);
      return;
    }

    // Check if hash is a section within a tab
    const section = document.getElementById(hash);
    if (section) {
      const parentTab = section.closest('.tab-content');
      if (parentTab) {
        switchTab(parentTab.id);
        setTimeout(() => {
          section.scrollIntoView({ behavior: 'smooth' });
        }, 100);
      }
    }
  }

  handleHash();
  window.addEventListener('hashchange', handleHash);

  // ============================================================
  // VISUAL JOURNEY - 4-Foundation Model with David Analogy
  // ============================================================

  const FOUNDATIONS = {
    F1: {
      name: "Finite Totality",
      analogy: "The Marble Block",
      formal: "|Ω| = N ≈ 10^(10^122)",
      desc: "All possibilities already exist, like all sculptures exist within the uncarved marble. There is no infinite - only the complete finite set of all that could be. The Bekenstein bound tells us how large this 'marble block' is.",
      confidence: 90,
      results: [
        { id: "R1", name: "N Estimation", analogy: "Size of the Block", category: "math" },
        { id: "R13", name: "ℏ Definition", analogy: "Minimum Chip Size", category: "math" }
      ]
    },
    F2: {
      name: "Metric Structure",
      analogy: "The Grain",
      formal: "d: Ω × Ω → ℝ≥0",
      desc: "The marble has inherent structure - grain that determines which forms are possible. Configurations have natural adjacency relationships. This metric structure gives rise to π, determines what neighbors what, and sets the fundamental limits of precision.",
      confidence: 95,
      results: [
        { id: "R2", name: "π-Emergence", analogy: "Curves in the Grain", category: "math" },
        { id: "R3", name: "Adjacency Structure", analogy: "What Neighbors What", category: "math" },
        { id: "R15", name: "Uncertainty Relations", analogy: "Grain Limits Precision", category: "physics" },
        { id: "R21", name: "Entanglement d_max", analogy: "Distant Grain Alignment", category: "prediction" }
      ]
    },
    F3: {
      name: "Traversal = Time",
      analogy: "The Sculpting",
      formal: "γ: τ → Ω where τ IS time",
      desc: "The ordering parameter τ IS physical time. Time is not a separate container - the sequence of traversal through configurations IS time itself. This explains gravity, superposition, and why there is no mysterious 'collapse'.",
      confidence: 85,
      results: [
        { id: "R4", name: "Time Definition", analogy: "The Stroke Count", category: "math" },
        { id: "R5", name: "Gravity = Drainage", analogy: "Chips Fall Downward", category: "physics" },
        { id: "R6", name: "Superposition", analogy: "Uncommitted Strokes", category: "physics" },
        { id: "R7", name: "No Collapse", analogy: "No Magic - Just Cutting", category: "physics" },
        { id: "R8", name: "Born Rule", analogy: "Natural Proportions", category: "physics" },
        { id: "R14", name: "Frequency-Energy", analogy: "Vibration of the Chisel", category: "physics" },
        { id: "R16", name: "Measurement Selection", analogy: "Chisel Choice", category: "physics" }
      ]
    },
    F4: {
      name: "CPT Symmetry",
      analogy: "The Mirror",
      formal: "CPT: M⁺ ↔ M⁻",
      desc: "Every form has a mirror image in the uncarved portion. What is carved away in one view is revealed in its reflection. This Boyle-Turok symmetry explains dual manifolds, conservation laws, the arrow of time, dark energy, and the nature of the Big Bang.",
      confidence: 90,
      results: [
        { id: "R9", name: "Dual Manifolds", analogy: "Form and Void", category: "physics" },
        { id: "R10", name: "Conservation Laws", analogy: "Nothing Lost", category: "physics" },
        { id: "R11", name: "Arrow of Time", analogy: "Direction of Carving", category: "physics" },
        { id: "R12", name: "Cyclic Cosmology", analogy: "The Sculpture Complete", category: "physics" },
        { id: "R17", name: "Dark Energy", analogy: "Pressure from the Void", category: "physics" },
        { id: "R18", name: "Big Bang as Boundary", analogy: "Edge of the Block", category: "physics" },
        { id: "R19", name: "Entropy Gradient", analogy: "Fresh vs Worked Marble", category: "physics" },
        { id: "R20", name: "CMB Patterns", analogy: "Grain in the Surface", category: "prediction" }
      ]
    }
  };

  // ============================================================
  // THREE.JS POINT CLOUD VISUALIZATIONS
  // Each foundation gets a 3D visualization reflecting its mathematics
  // ============================================================

  const pointCloudScenes = {};

  function initPointClouds() {
    // Only initialize if Three.js is available
    if (typeof THREE === 'undefined') {
      console.warn('Three.js not loaded');
      return;
    }

    // F1: Finite Configuration Space |Ω| = N
    // A rotating 3D cube of points representing all configurations σ ∈ Ω
    initF1PointCloud();

    // F2: Metric Structure d: Ω × Ω → ℝ
    // Points connected by edges showing metric distances
    initF2MetricGraph();

    // F3: Traversal Path γ: T → Ω
    // A path being traced through the configuration space
    initF3Traversal();

    // F4: CPT Symmetry M⁺ ↔ M⁻
    // Two mirrored point clouds breathing in anti-phase
    initF4MirrorManifolds();
  }

  function initF1PointCloud() {
    const container = document.getElementById('canvas-f1');
    if (!container) return;

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.z = 4.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);

    // Create nebula-like point cloud (all configurations σ ∈ Ω)
    const particleCount = 2000;
    const positions = [];
    const colors = [];
    const sizes = [];
    const phases = [];

    const baseColor = new THREE.Color(0xf5f5dc);
    const accentColor = new THREE.Color(0xffd700);

    for (let i = 0; i < particleCount; i++) {
      // Spherical distribution with density variation
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 0.5 + Math.random() * 1.5 * Math.pow(Math.random(), 0.5);

      positions.push(
        Math.sin(phi) * Math.cos(theta) * r,
        Math.sin(phi) * Math.sin(theta) * r,
        Math.cos(phi) * r
      );

      // Gradient from core to edge
      const distFromCenter = r / 2;
      const colorMix = Math.random();
      const color = new THREE.Color().lerpColors(accentColor, baseColor, distFromCenter);
      colors.push(color.r, color.g, color.b);

      // Variable sizes with larger particles in core
      sizes.push(0.02 + (1 - distFromCenter) * 0.08 * Math.random());
      phases.push(Math.random() * Math.PI * 2);
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    // Custom shader for glow effect
    const material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        pixelRatio: { value: window.devicePixelRatio }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vAlpha;
        uniform float time;
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          float pulse = 0.8 + 0.4 * sin(time * 2.0 + position.x * 3.0 + position.y * 2.0);
          gl_PointSize = size * pulse * 300.0 / -mvPosition.z;
          vAlpha = 0.6 + 0.4 * sin(time + position.z * 5.0);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          float glow = 1.0 - smoothstep(0.0, 0.5, dist);
          glow = pow(glow, 1.5);
          gl_FragColor = vec4(vColor, glow * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // Outer glow ring
    const ringGeometry = new THREE.RingGeometry(1.8, 2.2, 64);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0xf5f5dc,
      transparent: true,
      opacity: 0.1,
      side: THREE.DoubleSide
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.rotation.x = Math.PI / 2;
    scene.add(ring);

    pointCloudScenes.f1 = { scene, camera, renderer, points, material, ring };

    function animateF1() {
      requestAnimationFrame(animateF1);
      const t = Date.now() * 0.001;

      material.uniforms.time.value = t;
      points.rotation.y += 0.003;
      points.rotation.x = Math.sin(t * 0.2) * 0.1;

      ring.rotation.z += 0.002;
      ringMaterial.opacity = 0.05 + 0.05 * Math.sin(t);

      renderer.render(scene, camera);
    }
    animateF1();
  }

  function initF2MetricGraph() {
    const container = document.getElementById('canvas-f2');
    if (!container) return;

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);

    // Create nodes (configurations in Ω) with layered structure
    const nodeCount = 60;
    const nodePositions = [];
    const nodeSizes = [];
    for (let i = 0; i < nodeCount; i++) {
      const layer = Math.floor(i / 20);
      const radius = 1.2 + layer * 0.6;
      const theta = (i % 20) * Math.PI * 2 / 20 + layer * 0.3;
      const phi = 0.8 + Math.random() * 0.4;
      nodePositions.push(new THREE.Vector3(
        Math.sin(phi) * Math.cos(theta) * radius,
        Math.cos(phi) * radius * 0.8 + (Math.random() - 0.5) * 0.5,
        Math.sin(phi) * Math.sin(theta) * radius
      ));
      nodeSizes.push(0.08 + (3 - layer) * 0.04);
    }

    // Glowing nodes using shader
    const nodeGeometry = new THREE.BufferGeometry();
    const nodePosArray = [];
    nodePositions.forEach(p => nodePosArray.push(p.x, p.y, p.z));
    nodeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nodePosArray, 3));
    nodeGeometry.setAttribute('size', new THREE.Float32BufferAttribute(nodeSizes, 1));

    const nodeMaterial = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: `
        attribute float size;
        varying float vGlow;
        uniform float time;
        void main() {
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vGlow = 0.7 + 0.3 * sin(time * 3.0 + position.x * 2.0);
          gl_PointSize = size * 400.0 / -mvPosition.z;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying float vGlow;
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          float glow = 1.0 - smoothstep(0.0, 0.5, dist);
          glow = pow(glow, 1.2);
          vec3 color = vec3(0.55, 0.36, 0.96);
          gl_FragColor = vec4(color, glow * vGlow);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const nodes = new THREE.Points(nodeGeometry, nodeMaterial);
    scene.add(nodes);

    // Create animated edge connections showing metric d(σᵢ, σⱼ)
    const maxDist = 1.8;
    const edgeData = [];
    for (let i = 0; i < nodeCount; i++) {
      for (let j = i + 1; j < nodeCount; j++) {
        const dist = nodePositions[i].distanceTo(nodePositions[j]);
        if (dist < maxDist) {
          edgeData.push({ from: i, to: j, dist: dist });
        }
      }
    }

    // Flowing particles along edges (representing metric flow)
    const flowParticleCount = edgeData.length * 3;
    const flowPositions = new Float32Array(flowParticleCount * 3);
    const flowColors = new Float32Array(flowParticleCount * 3);
    const flowProgress = new Float32Array(flowParticleCount);

    for (let i = 0; i < flowParticleCount; i++) {
      flowProgress[i] = Math.random();
      flowColors[i * 3] = 0.7;
      flowColors[i * 3 + 1] = 0.5;
      flowColors[i * 3 + 2] = 1.0;
    }

    const flowGeometry = new THREE.BufferGeometry();
    flowGeometry.setAttribute('position', new THREE.BufferAttribute(flowPositions, 3));
    flowGeometry.setAttribute('color', new THREE.BufferAttribute(flowColors, 3));
    const flowMaterial = new THREE.PointsMaterial({
      size: 0.04,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    const flowParticles = new THREE.Points(flowGeometry, flowMaterial);
    scene.add(flowParticles);

    // Subtle edge lines
    const edgePositions = [];
    edgeData.forEach(e => {
      edgePositions.push(
        nodePositions[e.from].x, nodePositions[e.from].y, nodePositions[e.from].z,
        nodePositions[e.to].x, nodePositions[e.to].y, nodePositions[e.to].z
      );
    });
    const edgeGeometry = new THREE.BufferGeometry();
    edgeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(edgePositions, 3));
    const edgeLineMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, transparent: true, opacity: 0.15 });
    const edges = new THREE.LineSegments(edgeGeometry, edgeLineMaterial);
    scene.add(edges);

    pointCloudScenes.f2 = { scene, camera, renderer, nodes, nodeMaterial, edges, flowParticles, flowProgress, edgeData, nodePositions };

    function animateF2() {
      requestAnimationFrame(animateF2);
      const t = Date.now() * 0.001;

      nodeMaterial.uniforms.time.value = t;
      nodes.rotation.y += 0.002;
      edges.rotation.y += 0.002;
      flowParticles.rotation.y += 0.002;

      // Animate flowing particles along edges
      for (let i = 0; i < flowParticleCount; i++) {
        flowProgress[i] = (flowProgress[i] + 0.008) % 1;
        const edgeIdx = i % edgeData.length;
        const edge = edgeData[edgeIdx];
        const from = nodePositions[edge.from];
        const to = nodePositions[edge.to];
        const prog = flowProgress[i];

        flowPositions[i * 3] = from.x + (to.x - from.x) * prog;
        flowPositions[i * 3 + 1] = from.y + (to.y - from.y) * prog;
        flowPositions[i * 3 + 2] = from.z + (to.z - from.z) * prog;
      }
      flowGeometry.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    animateF2();
  }

  function initF3Traversal() {
    const container = document.getElementById('canvas-f3');
    if (!container) return;

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);

    // Background configuration points (all possibilities that exist)
    const bgCount = 800;
    const bgPositions = [];
    const bgColors = [];
    for (let i = 0; i < bgCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 1 + Math.random() * 2;
      bgPositions.push(
        Math.sin(phi) * Math.cos(theta) * r,
        Math.sin(phi) * Math.sin(theta) * r,
        Math.cos(phi) * r
      );
      const intensity = 0.2 + 0.3 * Math.random();
      bgColors.push(0.02 * intensity, 0.71 * intensity, 0.83 * intensity);
    }
    const bgGeometry = new THREE.BufferGeometry();
    bgGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bgPositions, 3));
    bgGeometry.setAttribute('color', new THREE.Float32BufferAttribute(bgColors, 3));
    const bgMaterial = new THREE.PointsMaterial({
      size: 0.03,
      vertexColors: true,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending
    });
    const bgPoints = new THREE.Points(bgGeometry, bgMaterial);
    scene.add(bgPoints);

    // The traversal path γ: T → Ω (a beautiful 3D helix/knot)
    const pathPoints = [];
    for (let t = 0; t <= 1; t += 0.01) {
      const angle = t * Math.PI * 4;
      pathPoints.push(new THREE.Vector3(
        Math.sin(angle) * (1.2 + 0.5 * Math.sin(angle * 3)),
        (t - 0.5) * 3 + 0.3 * Math.sin(angle * 2),
        Math.cos(angle) * (1.2 + 0.5 * Math.cos(angle * 2))
      ));
    }

    // Path as glowing tube
    const pathCurve = new THREE.CatmullRomCurve3(pathPoints);
    const tubeGeometry = new THREE.TubeGeometry(pathCurve, 100, 0.02, 8, false);
    const tubeMaterial = new THREE.MeshBasicMaterial({
      color: 0x06b6d4,
      transparent: true,
      opacity: 0.3
    });
    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
    scene.add(tube);

    // The traverser (consciousness point) with glow
    const traverserGroup = new THREE.Group();

    const coreGeometry = new THREE.SphereGeometry(0.1, 32, 32);
    const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x06b6d4 });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    traverserGroup.add(core);

    // Glow halo around traverser
    const glowGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    const glowMaterial = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: `
        varying vec3 vNormal;
        void main() {
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec3 vNormal;
        uniform float time;
        void main() {
          float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          float pulse = 0.5 + 0.5 * sin(time * 5.0);
          gl_FragColor = vec4(0.02, 0.71, 0.83, intensity * pulse);
        }
      `,
      transparent: true,
      side: THREE.BackSide,
      blending: THREE.AdditiveBlending
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    traverserGroup.add(glow);
    scene.add(traverserGroup);

    // Trail of particles (past experience fading)
    const trailLength = 80;
    const trailPositions = new Float32Array(trailLength * 3);
    const trailColors = new Float32Array(trailLength * 3);
    const trailSizes = new Float32Array(trailLength);

    for (let i = 0; i < trailLength; i++) {
      const fade = 1 - i / trailLength;
      trailColors[i * 3] = 0.4 * fade;
      trailColors[i * 3 + 1] = 0.9 * fade;
      trailColors[i * 3 + 2] = 0.98 * fade;
      trailSizes[i] = 0.08 * fade;
    }

    const trailGeometry = new THREE.BufferGeometry();
    trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
    trailGeometry.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));

    const trailMaterial = new THREE.ShaderMaterial({
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * 300.0 / -mvPosition.z;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          float glow = 1.0 - smoothstep(0.0, 0.5, dist);
          gl_FragColor = vec4(vColor, glow);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Points(trailGeometry, trailMaterial);
    scene.add(trail);

    let pathT = 0;
    const trailHistory = [];

    pointCloudScenes.f3 = { scene, camera, renderer, tube, traverserGroup, trail, bgPoints, glowMaterial };

    function animateF3() {
      requestAnimationFrame(animateF3);
      const t = Date.now() * 0.001;

      glowMaterial.uniforms.time.value = t;

      // Move traverser along curved path
      pathT = (pathT + 0.002) % 1;
      const pos = pathCurve.getPoint(pathT);
      traverserGroup.position.copy(pos);

      // Update particle trail
      trailHistory.unshift(pos.clone());
      if (trailHistory.length > trailLength) trailHistory.pop();

      for (let i = 0; i < trailLength; i++) {
        if (i < trailHistory.length) {
          trailPositions[i * 3] = trailHistory[i].x;
          trailPositions[i * 3 + 1] = trailHistory[i].y;
          trailPositions[i * 3 + 2] = trailHistory[i].z;
        }
      }
      trailGeometry.attributes.position.needsUpdate = true;

      // Subtle rotation of background
      bgPoints.rotation.y += 0.0003;
      bgPoints.rotation.x = Math.sin(t * 0.1) * 0.05;

      renderer.render(scene, camera);
    }
    animateF3();
  }

  function initF4MirrorManifolds() {
    const container = document.getElementById('canvas-f4');
    if (!container) return;

    const width = container.clientWidth || 400;
    const height = container.clientHeight || 400;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
    camera.position.z = 5.5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.insertBefore(renderer.domElement, container.firstChild);

    // Central Σ boundary (Big Bang plane) as glowing disc
    const sigmaGeometry = new THREE.PlaneGeometry(0.1, 4);
    const sigmaMaterial = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        uniform float time;
        void main() {
          float dist = abs(vUv.x - 0.5) * 2.0;
          float pulse = 0.5 + 0.5 * sin(time * 3.0 + vUv.y * 10.0);
          float glow = (1.0 - dist) * pulse;
          vec3 color = vec3(0.93, 0.29, 0.6);
          gl_FragColor = vec4(color, glow * 0.8);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending
    });
    const sigma = new THREE.Mesh(sigmaGeometry, sigmaMaterial);
    scene.add(sigma);

    // M⁺ manifold (our universe - left side)
    const manifoldCount = 400;
    const mPlusPositions = [];
    const mPlusColors = [];
    const mPlusSizes = [];

    for (let i = 0; i < manifoldCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 0.3 + Math.random() * 1.2;
      const x = -1.5 + Math.sin(phi) * Math.cos(theta) * r * 0.7;
      const y = Math.cos(phi) * r;
      const z = Math.sin(phi) * Math.sin(theta) * r * 0.7;
      mPlusPositions.push(x, y, z);

      // Gradient from hot pink to coral
      const colorT = Math.random();
      mPlusColors.push(0.93, 0.29 + 0.4 * colorT, 0.6 + 0.3 * colorT);
      mPlusSizes.push(0.03 + 0.05 * Math.random());
    }

    const mPlusGeometry = new THREE.BufferGeometry();
    mPlusGeometry.setAttribute('position', new THREE.Float32BufferAttribute(mPlusPositions, 3));
    mPlusGeometry.setAttribute('color', new THREE.Float32BufferAttribute(mPlusColors, 3));
    mPlusGeometry.setAttribute('size', new THREE.Float32BufferAttribute(mPlusSizes, 1));

    const manifoldMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        phase: { value: 0 }
      },
      vertexShader: `
        attribute float size;
        attribute vec3 color;
        varying vec3 vColor;
        varying float vAlpha;
        uniform float time;
        uniform float phase;
        void main() {
          vColor = color;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          float breathe = 1.0 + 0.15 * sin(time * 1.5 + phase);
          vAlpha = 0.6 + 0.4 * sin(time * 2.0 + phase + position.y);
          gl_PointSize = size * breathe * 350.0 / -mvPosition.z;
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = length(center);
          float glow = 1.0 - smoothstep(0.0, 0.5, dist);
          glow = pow(glow, 1.3);
          gl_FragColor = vec4(vColor, glow * vAlpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const mPlus = new THREE.Points(mPlusGeometry, manifoldMaterial.clone());
    mPlus.material.uniforms.phase.value = 0;
    scene.add(mPlus);

    // M⁻ manifold (antiverse - right side, mirrored)
    const mMinusPositions = mPlusPositions.map((val, i) => i % 3 === 0 ? -val : val);
    const mMinusGeometry = new THREE.BufferGeometry();
    mMinusGeometry.setAttribute('position', new THREE.Float32BufferAttribute(mMinusPositions, 3));
    mMinusGeometry.setAttribute('color', new THREE.Float32BufferAttribute(mPlusColors, 3)); // Same colors
    mMinusGeometry.setAttribute('size', new THREE.Float32BufferAttribute(mPlusSizes, 1));

    const mMinus = new THREE.Points(mMinusGeometry, manifoldMaterial.clone());
    mMinus.material.uniforms.phase.value = Math.PI; // Anti-phase!
    scene.add(mMinus);

    // Connecting streams (entropy flow J^μ between manifolds)
    const streamCount = 50;
    const streamPositions = new Float32Array(streamCount * 6);
    const streamColors = new Float32Array(streamCount * 6);

    for (let i = 0; i < streamCount; i++) {
      const idx = Math.floor(Math.random() * manifoldCount);
      const y = mPlusPositions[idx * 3 + 1];
      // From M⁺ to Σ to M⁻
      streamPositions[i * 6] = mPlusPositions[idx * 3];
      streamPositions[i * 6 + 1] = y;
      streamPositions[i * 6 + 2] = mPlusPositions[idx * 3 + 2];
      streamPositions[i * 6 + 3] = mMinusPositions[idx * 3];
      streamPositions[i * 6 + 4] = y;
      streamPositions[i * 6 + 5] = mMinusPositions[idx * 3 + 2];

      streamColors[i * 6] = 0.93;
      streamColors[i * 6 + 1] = 0.29;
      streamColors[i * 6 + 2] = 0.6;
      streamColors[i * 6 + 3] = 0.93;
      streamColors[i * 6 + 4] = 0.29;
      streamColors[i * 6 + 5] = 0.6;
    }

    const streamGeometry = new THREE.BufferGeometry();
    streamGeometry.setAttribute('position', new THREE.BufferAttribute(streamPositions, 3));
    streamGeometry.setAttribute('color', new THREE.BufferAttribute(streamColors, 3));
    const streamMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      transparent: true,
      opacity: 0.1,
      blending: THREE.AdditiveBlending
    });
    const streams = new THREE.LineSegments(streamGeometry, streamMaterial);
    scene.add(streams);

    pointCloudScenes.f4 = { scene, camera, renderer, mPlus, mMinus, sigma, sigmaMaterial, streams, streamMaterial };

    function animateF4() {
      requestAnimationFrame(animateF4);
      const t = Date.now() * 0.001;

      // Update shader uniforms
      sigmaMaterial.uniforms.time.value = t;
      mPlus.material.uniforms.time.value = t;
      mMinus.material.uniforms.time.value = t;

      // Rotate both manifolds together
      mPlus.rotation.y += 0.002;
      mMinus.rotation.y += 0.002;
      streams.rotation.y += 0.002;

      // Pulse the streams opacity
      streamMaterial.opacity = 0.05 + 0.1 * Math.abs(Math.sin(t * 2));

      renderer.render(scene, camera);
    }
    animateF4();
  }

  // Handle window resize for all canvases
  function handleResize() {
    Object.entries(pointCloudScenes).forEach(([id, scene]) => {
      const container = document.getElementById('canvas-' + id);
      if (!container) return;
      const width = container.clientWidth;
      const height = container.clientHeight;
      scene.camera.aspect = width / height;
      scene.camera.updateProjectionMatrix();
      scene.renderer.setSize(width, height);
    });
  }
  window.addEventListener('resize', handleResize);

  // Initialize point clouds when journey tab is visible
  function initOnVisible() {
    const journeyTab = document.getElementById('journey');
    if (journeyTab && journeyTab.classList.contains('active')) {
      if (!pointCloudScenes.f1) initPointClouds();
    }
  }

  // Observer for tab changes
  const observer = new MutationObserver(() => initOnVisible());
  const journeyEl = document.getElementById('journey');
  if (journeyEl) {
    observer.observe(journeyEl, { attributes: true, attributeFilter: ['class'] });
  }

  // Init immediately if on journey tab
  if (window.location.hash === '#journey') {
    setTimeout(initPointClouds, 100);
  }

  // ============================================================
  // DESIGN SPEC TOGGLE
  // ============================================================

  window.toggleSpec = function(button) {
    const specDiv = button.nextElementSibling;
    button.classList.toggle('active');
    specDiv.classList.toggle('active');
  };

  // ============================================================
  // INNOVATION TAB ANIMATIONS
  // Animated visualizations for each technological innovation
  // ============================================================

  const innovationScenes = {};
  let innovationsInitialized = false;

  function initInnovationAnimations() {
    if (innovationsInitialized) return;
    if (typeof THREE === 'undefined') return;
    innovationsInitialized = true;

    // Innovation 1: Quantum Error Correction - Lattice of connected nodes
    initInnovation1();
    // Innovation 2: Entropic Propulsion - Flowing particles with directional bias
    initInnovation2();
    // Innovation 3: Entanglement Topology - Connected distant points
    initInnovation3();
    // Innovation 4: Finite Path Computation - Discrete path summation
    initInnovation4();
    // Innovation 5: Entropy Differential - Two-sided flow
    initInnovation5();
    // Innovation 6: π-Structure - Circular pattern encoding
    initInnovation6();
  }

  function createInnovationScene(containerId) {
    const container = document.getElementById(containerId);
    if (!container) return null;

    const width = container.clientWidth || 350;
    const height = container.clientHeight || 200;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
    camera.position.z = 4;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    return { scene, camera, renderer, container };
  }

  function initInnovation1() {
    const ctx = createInnovationScene('canvas-innovation-1');
    if (!ctx) return;

    // Create a lattice of quantum states with error correction connections
    const gridSize = 5;
    const spacing = 0.6;
    const positions = [];
    const colors = [];

    for (let x = 0; x < gridSize; x++) {
      for (let y = 0; y < gridSize; y++) {
        positions.push(
          (x - gridSize/2) * spacing,
          (y - gridSize/2) * spacing,
          (Math.random() - 0.5) * 0.5
        );
        colors.push(0.55, 0.36, 0.96);
      }
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
      size: 0.12,
      vertexColors: true,
      transparent: true,
      opacity: 0.9
    });

    const points = new THREE.Points(geometry, material);
    ctx.scene.add(points);

    // Add connecting lines for error correction topology
    const linePositions = [];
    for (let i = 0; i < gridSize * gridSize; i++) {
      const x1 = positions[i * 3];
      const y1 = positions[i * 3 + 1];
      const z1 = positions[i * 3 + 2];
      for (let j = i + 1; j < gridSize * gridSize; j++) {
        const x2 = positions[j * 3];
        const y2 = positions[j * 3 + 1];
        const z2 = positions[j * 3 + 2];
        const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        if (dist < spacing * 1.5) {
          linePositions.push(x1, y1, z1, x2, y2, z2);
        }
      }
    }

    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x8b5cf6, transparent: true, opacity: 0.3 });
    const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
    ctx.scene.add(lines);

    innovationScenes.i1 = ctx;

    function animate() {
      requestAnimationFrame(animate);
      points.rotation.z += 0.002;
      lines.rotation.z += 0.002;

      // Pulse effect for error correction visualization
      const t = Date.now() * 0.003;
      material.opacity = 0.7 + 0.2 * Math.sin(t);

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  function initInnovation2() {
    const ctx = createInnovationScene('canvas-innovation-2');
    if (!ctx) return;

    // Flowing particles with directional entropy gradient
    const particleCount = 200;
    const positions = new Float32Array(particleCount * 3);
    const velocities = [];

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 4;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
      velocities.push({ x: 0.02 + Math.random() * 0.01, y: (Math.random() - 0.5) * 0.005 });
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
      size: 0.06,
      color: 0xf5f5dc,
      transparent: true,
      opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    ctx.scene.add(particles);

    // Add a directional arrow
    const arrowGeometry = new THREE.BufferGeometry();
    arrowGeometry.setAttribute('position', new THREE.Float32BufferAttribute([
      -1.8, 0, 0, 1.5, 0, 0,
      1.5, 0, 0, 1.2, 0.2, 0,
      1.5, 0, 0, 1.2, -0.2, 0
    ], 3));
    const arrowMaterial = new THREE.LineBasicMaterial({ color: 0xf5f5dc, opacity: 0.4, transparent: true });
    const arrow = new THREE.LineSegments(arrowGeometry, arrowMaterial);
    ctx.scene.add(arrow);

    innovationScenes.i2 = { ...ctx, positions, velocities };

    function animate() {
      requestAnimationFrame(animate);

      // Update particle positions with directional flow
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += velocities[i].x;
        positions[i * 3 + 1] += velocities[i].y;

        // Wrap around
        if (positions[i * 3] > 2) {
          positions[i * 3] = -2;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
        }
      }
      geometry.attributes.position.needsUpdate = true;

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  function initInnovation3() {
    const ctx = createInnovationScene('canvas-innovation-3');
    if (!ctx) return;

    // Two clusters of points with entanglement connections
    const cluster1 = [];
    const cluster2 = [];

    for (let i = 0; i < 15; i++) {
      cluster1.push(new THREE.Vector3(
        -1.2 + (Math.random() - 0.5) * 0.8,
        (Math.random() - 0.5) * 1,
        (Math.random() - 0.5) * 0.5
      ));
      cluster2.push(new THREE.Vector3(
        1.2 + (Math.random() - 0.5) * 0.8,
        (Math.random() - 0.5) * 1,
        (Math.random() - 0.5) * 0.5
      ));
    }

    // Points for clusters
    const allPositions = [];
    cluster1.forEach(p => allPositions.push(p.x, p.y, p.z));
    cluster2.forEach(p => allPositions.push(p.x, p.y, p.z));

    const pointGeometry = new THREE.BufferGeometry();
    pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute(allPositions, 3));
    const pointMaterial = new THREE.PointsMaterial({ size: 0.1, color: 0x8b5cf6, transparent: true, opacity: 0.9 });
    const points = new THREE.Points(pointGeometry, pointMaterial);
    ctx.scene.add(points);

    // Entanglement connections between clusters
    const entanglementLines = [];
    for (let i = 0; i < 5; i++) {
      const p1 = cluster1[i];
      const p2 = cluster2[i];
      entanglementLines.push(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
    }

    const lineGeometry = new THREE.BufferGeometry();
    lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(entanglementLines, 3));
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xc4b5fd, transparent: true, opacity: 0.5 });
    const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
    ctx.scene.add(lines);

    innovationScenes.i3 = ctx;

    function animate() {
      requestAnimationFrame(animate);

      // Pulsing entanglement lines
      const t = Date.now() * 0.002;
      lineMaterial.opacity = 0.3 + 0.3 * Math.sin(t);

      points.rotation.y += 0.002;
      lines.rotation.y += 0.002;

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  function initInnovation4() {
    const ctx = createInnovationScene('canvas-innovation-4');
    if (!ctx) return;

    // Multiple paths from start to end point
    const startPoint = new THREE.Vector3(-1.5, 0, 0);
    const endPoint = new THREE.Vector3(1.5, 0, 0);

    const paths = [];
    const pathCount = 8;

    for (let p = 0; p < pathCount; p++) {
      const pathPositions = [];
      const amplitude = (Math.random() - 0.5) * 1.5;
      const frequency = 1 + Math.random() * 2;

      for (let t = 0; t <= 1; t += 0.05) {
        const x = startPoint.x + (endPoint.x - startPoint.x) * t;
        const y = amplitude * Math.sin(t * Math.PI * frequency);
        const z = (Math.random() - 0.5) * 0.3;
        pathPositions.push(x, y, z);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(pathPositions, 3));
      const material = new THREE.LineBasicMaterial({
        color: 0x06b6d4,
        transparent: true,
        opacity: 0.3 + Math.random() * 0.3
      });
      const line = new THREE.Line(geometry, material);
      ctx.scene.add(line);
      paths.push({ line, material });
    }

    // Start and end markers
    const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x06b6d4 });
    const startMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    startMarker.position.copy(startPoint);
    ctx.scene.add(startMarker);

    const endMarker = new THREE.Mesh(markerGeometry, markerMaterial);
    endMarker.position.copy(endPoint);
    ctx.scene.add(endMarker);

    innovationScenes.i4 = { ...ctx, paths };

    function animate() {
      requestAnimationFrame(animate);

      // Cycle through paths highlighting
      const t = Date.now() * 0.001;
      paths.forEach((p, i) => {
        const phase = (t + i * 0.5) % (pathCount * 0.5);
        p.material.opacity = 0.2 + 0.4 * Math.max(0, 1 - Math.abs(phase - i * 0.5));
      });

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  function initInnovation5() {
    const ctx = createInnovationScene('canvas-innovation-5');
    if (!ctx) return;

    // Two sides with particles flowing between them
    const particleCount = 100;
    const leftPositions = new Float32Array(particleCount * 3);
    const rightPositions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
      leftPositions[i * 3] = -1.5 + (Math.random() - 0.5) * 1;
      leftPositions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      leftPositions[i * 3 + 2] = (Math.random() - 0.5) * 1;

      rightPositions[i * 3] = 1.5 + (Math.random() - 0.5) * 1;
      rightPositions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      rightPositions[i * 3 + 2] = (Math.random() - 0.5) * 1;
    }

    const leftGeometry = new THREE.BufferGeometry();
    leftGeometry.setAttribute('position', new THREE.BufferAttribute(leftPositions, 3));
    const leftMaterial = new THREE.PointsMaterial({ size: 0.06, color: 0xec4899, transparent: true, opacity: 0.8 });
    const leftPoints = new THREE.Points(leftGeometry, leftMaterial);
    ctx.scene.add(leftPoints);

    const rightGeometry = new THREE.BufferGeometry();
    rightGeometry.setAttribute('position', new THREE.BufferAttribute(rightPositions, 3));
    const rightMaterial = new THREE.PointsMaterial({ size: 0.06, color: 0xec4899, transparent: true, opacity: 0.4 });
    const rightPoints = new THREE.Points(rightGeometry, rightMaterial);
    ctx.scene.add(rightPoints);

    // Central dividing line (Σ boundary)
    const dividerGeometry = new THREE.BufferGeometry();
    dividerGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, -1.2, 0, 0, 1.2, 0], 3));
    const dividerMaterial = new THREE.LineBasicMaterial({ color: 0xec4899, opacity: 0.6, transparent: true });
    const divider = new THREE.Line(dividerGeometry, dividerMaterial);
    ctx.scene.add(divider);

    innovationScenes.i5 = ctx;

    function animate() {
      requestAnimationFrame(animate);

      // Anti-phase breathing
      const t = Date.now() * 0.001;
      const scaleL = 1 + 0.1 * Math.sin(t);
      const scaleR = 1 + 0.1 * Math.sin(t + Math.PI);

      leftPoints.scale.set(scaleL, scaleL, scaleL);
      rightPoints.scale.set(scaleR, scaleR, scaleR);

      leftMaterial.opacity = 0.6 + 0.2 * Math.sin(t);
      rightMaterial.opacity = 0.3 + 0.2 * Math.sin(t + Math.PI);

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  function initInnovation6() {
    const ctx = createInnovationScene('canvas-innovation-6');
    if (!ctx) return;

    // Circular pattern representing π structure
    const rings = [];
    const ringCount = 5;

    for (let r = 0; r < ringCount; r++) {
      const radius = 0.4 + r * 0.3;
      const pointCount = 20 + r * 10;
      const positions = [];

      for (let i = 0; i < pointCount; i++) {
        const angle = (i / pointCount) * Math.PI * 2;
        positions.push(
          Math.cos(angle) * radius,
          Math.sin(angle) * radius,
          (Math.random() - 0.5) * 0.1
        );
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.PointsMaterial({
        size: 0.05,
        color: 0x22c55e,
        transparent: true,
        opacity: 0.5 + (r / ringCount) * 0.4
      });
      const points = new THREE.Points(geometry, material);
      ctx.scene.add(points);
      rings.push(points);
    }

    // Central π symbol representation
    const centerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const centerMaterial = new THREE.MeshBasicMaterial({ color: 0x22c55e });
    const center = new THREE.Mesh(centerGeometry, centerMaterial);
    ctx.scene.add(center);

    innovationScenes.i6 = { ...ctx, rings };

    function animate() {
      requestAnimationFrame(animate);

      // Rotate rings at different speeds (π-like irrational ratios)
      rings.forEach((ring, i) => {
        ring.rotation.z += 0.003 * (1 + i * 0.618); // Golden ratio-ish
      });

      ctx.renderer.render(ctx.scene, ctx.camera);
    }
    animate();
  }

  // Observer for innovations tab visibility
  const innovationsObserver = new MutationObserver(() => {
    const innovationsTab = document.getElementById('innovations');
    if (innovationsTab && innovationsTab.classList.contains('active')) {
      if (!innovationsInitialized) initInnovationAnimations();
    }
  });
  const innovationsEl = document.getElementById('innovations');
  if (innovationsEl) {
    innovationsObserver.observe(innovationsEl, { attributes: true, attributeFilter: ['class'] });
  }

  // Init immediately if on innovations tab
  if (window.location.hash === '#innovations') {
    setTimeout(initInnovationAnimations, 100);
  }
});

// Landing page enter function
function enterSite() {
  document.getElementById('landingPage').classList.add('hidden');
  document.getElementById('mainSite').classList.add('visible');
  window.scrollTo(0, 0);
  // Store preference
  sessionStorage.setItem('enteredSite', 'true');
}

// Check if user already entered (during session)
document.addEventListener('DOMContentLoaded', function() {
  const hasEntered = sessionStorage.getItem('enteredSite');
  const hash = window.location.hash;

  // Skip landing if already entered or if URL has a specific tab hash
  if (hasEntered || (hash && hash !== '#' && hash !== '#landing')) {
    document.getElementById('landingPage').classList.add('hidden');
    document.getElementById('mainSite').classList.add('visible');
  }

  // Initialize hero particle system
  initHeroParticles();

  // Initialize scroll animations
  initScrollAnimations();
});

// ===============================================
// HERO PARTICLE SYSTEM - Entropy Flow Visualization
// ===============================================
function initHeroParticles() {
  const canvas = document.getElementById('hero-particles');
  if (!canvas) return;

  const landingPage = document.getElementById('landingPage');
  if (!landingPage) return;

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // Particle system parameters
  const particleCount = 2000;
  const positions = new Float32Array(particleCount * 3);
  const velocities = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  const sizes = new Float32Array(particleCount);
  const phases = new Float32Array(particleCount);

  // Color palette matching RDT brand
  const colorPalette = [
    new THREE.Color(0x8b5cf6), // Purple
    new THREE.Color(0x06b6d4), // Cyan
    new THREE.Color(0xf5f5dc), // Gold/Beige
    new THREE.Color(0xec4899), // Pink
    new THREE.Color(0xa78bfa), // Light purple
  ];

  // Initialize particles in a spiral/vortex pattern
  for (let i = 0; i < particleCount; i++) {
    const i3 = i * 3;

    // Spawn in expanding spiral
    const theta = (i / particleCount) * Math.PI * 20 + Math.random() * 0.5;
    const r = 20 + (i / particleCount) * 80 + Math.random() * 30;
    const y = (Math.random() - 0.5) * 100;

    positions[i3] = Math.cos(theta) * r;
    positions[i3 + 1] = y;
    positions[i3 + 2] = Math.sin(theta) * r + (Math.random() - 0.5) * 50;

    // Spiral inward velocity
    const speed = 0.05 + Math.random() * 0.1;
    velocities[i3] = -positions[i3] * speed * 0.005;
    velocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
    velocities[i3 + 2] = -positions[i3 + 2] * speed * 0.005;

    // Random color from palette
    const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
    colors[i3] = color.r;
    colors[i3 + 1] = color.g;
    colors[i3 + 2] = color.b;

    sizes[i] = Math.random() * 3 + 0.5;
    phases[i] = Math.random() * Math.PI * 2;
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
  geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

  // Custom shader material for glowing particles
  const material = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      pixelRatio: { value: renderer.getPixelRatio() }
    },
    vertexShader: `
      attribute float size;
      attribute vec3 color;
      attribute float phase;
      varying vec3 vColor;
      varying float vAlpha;
      uniform float time;

      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        float dist = length(position.xz);

        // Pulsing size based on distance and time
        float pulse = 1.0 + 0.3 * sin(time * 2.0 + phase);

        // Fade out at edges
        vAlpha = smoothstep(150.0, 30.0, dist) * (0.3 + 0.7 * sin(time + phase) * 0.5 + 0.5);

        gl_PointSize = size * pulse * (250.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      varying float vAlpha;

      void main() {
        float r = distance(gl_PointCoord, vec2(0.5));
        if (r > 0.5) discard;

        // Soft glow falloff
        float glow = 1.0 - smoothstep(0.0, 0.5, r);
        float alpha = vAlpha * glow;

        gl_FragColor = vec4(vColor, alpha * 0.7);
      }
    `,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  const particles = new THREE.Points(geometry, material);
  scene.add(particles);

  // Add central glow sphere
  const glowGeometry = new THREE.SphereGeometry(8, 32, 32);
  const glowMaterial = new THREE.ShaderMaterial({
    uniforms: { time: { value: 0 } },
    vertexShader: `
      varying vec3 vNormal;
      void main() {
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec3 vNormal;
      uniform float time;
      void main() {
        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
        float pulse = 0.5 + 0.5 * sin(time * 1.5);
        vec3 color = mix(vec3(0.55, 0.36, 0.96), vec3(0.02, 0.71, 0.83), pulse);
        gl_FragColor = vec4(color, intensity * 0.3);
      }
    `,
    transparent: true,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending
  });
  const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
  scene.add(glowSphere);

  camera.position.z = 120;
  camera.position.y = 20;

  // Mouse interaction
  let mouseX = 0, mouseY = 0;
  document.addEventListener('mousemove', (e) => {
    mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
    mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
  });

  // Animation loop
  let time = 0;
  let animationId;

  function animate() {
    animationId = requestAnimationFrame(animate);

    // Don't animate if landing page is hidden
    if (landingPage.classList.contains('hidden')) {
      cancelAnimationFrame(animationId);
      return;
    }

    time += 0.01;
    material.uniforms.time.value = time;
    glowMaterial.uniforms.time.value = time;

    const pos = geometry.attributes.position.array;

    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;

      // Update position with velocity
      pos[i3] += velocities[i3];
      pos[i3 + 1] += velocities[i3 + 1];
      pos[i3 + 2] += velocities[i3 + 2];

      // Add spiral rotation
      const x = pos[i3];
      const z = pos[i3 + 2];
      const angle = 0.003;
      pos[i3] = x * Math.cos(angle) - z * Math.sin(angle);
      pos[i3 + 2] = x * Math.sin(angle) + z * Math.cos(angle);

      // Reset particles that get too close to center
      const dist = Math.sqrt(pos[i3]**2 + pos[i3+2]**2);
      if (dist < 8) {
        const theta = Math.random() * Math.PI * 2;
        const r = 80 + Math.random() * 60;
        pos[i3] = Math.cos(theta) * r;
        pos[i3 + 2] = Math.sin(theta) * r;
        pos[i3 + 1] = (Math.random() - 0.5) * 100;
      }
    }

    geometry.attributes.position.needsUpdate = true;

    // Mouse-influenced camera movement
    camera.position.x += (mouseX * 15 - camera.position.x) * 0.02;
    camera.position.y += (-mouseY * 10 + 20 - camera.position.y) * 0.02;
    camera.lookAt(0, 0, 0);

    // Subtle rotation
    particles.rotation.y += 0.0005;
    glowSphere.rotation.y -= 0.002;

    renderer.render(scene, camera);
  }
  animate();

  // Handle resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// ===============================================
// SCROLL ANIMATIONS - Intersection Observer
// ===============================================
function initScrollAnimations() {
  // Add animate-on-scroll class to elements that should animate
  const animatableSelectors = [
    '.axiom', '.theorem', '.definition', '.corollary',
    '.boxed', '.credit-box', '.theory-box', '.insight-box',
    '.spec-card', '.innovation-card', '.faq-item',
    'table', '.diagram', '.dependency-tree'
  ];

  animatableSelectors.forEach(selector => {
    document.querySelectorAll(selector).forEach((el, index) => {
      if (!el.classList.contains('animate-on-scroll')) {
        el.classList.add('animate-on-scroll');
        el.style.transitionDelay = `${Math.min(index * 0.05, 0.3)}s`;
      }
    });
  });

  // Create intersection observer
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
      }
    });
  }, {
    threshold: 0.1,
    rootMargin: '0px 0px -50px 0px'
  });

  // Observe all animate-on-scroll elements
  document.querySelectorAll('.animate-on-scroll').forEach(el => {
    observer.observe(el);
  });
}

// ===============================================
// GSAP ANIMATIONS - For enhanced effects
// ===============================================
if (typeof gsap !== 'undefined') {
  // Animate foundation panels on hover
  document.querySelectorAll('.foundation-panel').forEach(panel => {
    panel.addEventListener('mouseenter', () => {
      gsap.to(panel, {
        scale: 1.02,
        duration: 0.3,
        ease: 'power2.out'
      });
    });
    panel.addEventListener('mouseleave', () => {
      gsap.to(panel, {
        scale: 1,
        duration: 0.3,
        ease: 'power2.out'
      });
    });
  });

  // Animate tab content on switch
  const originalSwitchTab = window.switchTab;
  if (originalSwitchTab) {
    window.switchTab = function(tabId) {
      const content = document.getElementById(tabId);
      if (content) {
        gsap.fromTo(content,
          { opacity: 0, y: 20 },
          { opacity: 1, y: 0, duration: 0.4, ease: 'power2.out' }
        );
      }
      originalSwitchTab(tabId);
    };
  }
}
</script>

</div><!-- end main-site -->

</body>
</html>
